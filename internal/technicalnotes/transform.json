[
  {
    "paragraph": "Our goal as software professionals is to deliver useful, working software to users as quickly as possible."
  },
  {
    "paragraph": "Releasing software is too often an art; it should be an engineering discipline."
  },
  {
    "paragraph": "The key to fast feedback is automation."
  },
  {
    "paragraph": "The key to reducing stress is to have the kind of automated deployment process that we have described, to perform it frequently, and to have a good story when it comes to your ability to back changes out should the worst happen."
  },
  {
    "paragraph": "In software, when something is painful, the way to reduce the pain is to do it more frequently, not less."
  },
  {
    "paragraph": "You should automate as much as you possibly can."
  },
  {
    "paragraph": "If releasing software is painful, aim to release it every time somebody checks in a change that passes all the automated tests. If you can’t release it to real users upon every change, release it to a production-like environment upon every check-in. If creating application documentation is painful, do it as you develop new features instead of leaving it to the end. Make documentation for a feature part of the definition of done, and automate the process as far as possible."
  },
  {
    "paragraph": "The earlier you catch defects, the cheaper they are to fix."
  },
  {
    "paragraph": "Bring the pain forward."
  },
  {
    "paragraph": "Every single artifact related to the creation of your software should be under version control"
  },
  {
    "paragraph": "Analysts should store requirements documents. Testers should keep their test scripts and procedures in version control. Project managers should save their release plans, progress charts, and risk logs here. In short, every member of the team should store any document or file related to the project in version control."
  },
  {
    "paragraph": "One thing that we don’t recommend that you keep in version control is the binary output of your application’s compilation."
  },
  {
    "paragraph": "In these situations, a commit message explaining what the person was doing when they committed that change can save you hours of debugging."
  },
  {
    "paragraph": "One style we like is a multiparagraph commit message in which the first paragraph is a summary and the following paragraphs add more detail. The first paragraph is what gets shown on line-per-commit displays—think of it as a newspaper headline, giving the reader enough information to figure out if she is interested in reading on."
  },
  {
    "paragraph": "Maven, a build tool for Java, allows you to specify the JARs your application depends on and downloads them from repositories on the Internet (or a local cache, if you have one)."
  },
  {
    "paragraph": "Configurable software is not always the cheaper solution it appears to be. It’s almost always better to focus on delivering the high-value functionality with little configuration and then add configuration options later when necessary."
  },
  {
    "paragraph": "Try to imagine someone reading the configuration file without a manual—it should be possible to understand what the configuration properties are."
  },
  {
    "paragraph": "Avoid overengineering the configuration system. Keep it as simple as you can."
  },
  {
    "paragraph": "Virtualization can also improve the efficiency of the environment management process. Instead of creating a new environment from scratch using an automated process, you can simply take a copy of each box in your environment and store it as a baseline. Then it is trivial to create new environments—it can be done by clicking a button. Virtualization has other benefits, such as the ability to consolidate hardware and to standardize your hardware platform even if your applications require heterogeneous environments."
  },
  {
    "paragraph": "The goal of continuous integration is that the software is in a working state all the time."
  },
  {
    "paragraph": "Everything in your project must be checked in to a single version control repository: code, tests, database scripts, build and deployment scripts, and anything else needed to create, install, run, and test your application."
  },
  {
    "paragraph": "Every time a build fails, it indicates that a problem has been found that may otherwise have made it into production."
  },
  {
    "paragraph": "Continuous integration is a practice, not a tool, and it depends upon discipline to make it effective."
  },
  {
    "paragraph": "The objective of our CI system is to ensure that our software is working, in essence, all of the time"
  },
  {
    "paragraph": "Until their check-in has compiled and passed its commit tests, the developers should not start any new task. They shouldn’t go out for lunch or start a meeting. They should be paying sufficient attention to the build to know its outcome within a few seconds of the commit stage completing."
  },
  {
    "paragraph": "If the commit succeeds, the developers are then, and only then, free to move on to their next task. If it fails, they are at hand to start determining the nature of the problem and fixing it—with another check-in or a revert to the previous version in version control, that is, backing out their changes until they understand how to make them work"
  },
  {
    "paragraph": "The effect of a broken build generally, and specifically a build left broken at the end of a day’s work, is magnified if you are working in a distributed development team with groups in different time zones. In these circumstances, going home on a broken build is perhaps one of the most effective ways of alienating your remote colleagues. Just to be absolutely clear, we are not recommending that you stay late to fix the build after working hours."
  },
  {
    "paragraph": "Whatever our reaction to a failed commit stage, it is important that we get everything working again quickly. If we can’t fix the problem quickly, for whatever reason, we should revert to the previous change-set held in revision control and remedy the problem in our local environment."
  },
  {
    "paragraph": "Establish a team rule: When the build breaks on check-in, try to fix it for ten minutes. If, after ten minutes, you aren’t finished with the solution, revert to the previous version from your version control system."
  },
  {
    "paragraph": "If you commit a change and all the tests you wrote pass, but others break, the build is still broken. Usually this means that you have introduced a regression bug into the application. It is your responsibility—because you made the change—to fix all tests that are not passing as a result of your changes."
  },
  {
    "paragraph": "Refactoring means making a series of small, incremental changes that improve your code without changing your application’s behavior. CI and test-driven development enable refactoring by assuring you that your changes don’t alter the existing behavior of the application. Thus your team becomes free to make changes which might touch large areas of the code without worrying that they can break the application. This practice also enables frequent check-ins—developers check in after each small, incremental change."
  },
  {
    "paragraph": "As we have said before, CI works best with small, frequent commits. If the commit tests take a long time to run, it can have a seriously detrimental effect on the productivity of the team because of the time spent waiting for the build and test process to complete. This will, in turn, discourage frequent check-ins, so the team will start to store up their check-ins, making each one more complex—with more likelihood of merge conflicts and more chance of introducing errors, and so failing the tests. All this slows everything down even further."
  },
  {
    "paragraph": "Testing is a cross-functional activity that involves the whole team, and should be done continuously from the beginning of the project. Building quality in means writing automated tests at multiple levels (unit, component, and acceptance) and running them as part of the deployment pipeline, which is triggered every time a change is made to your application, its configuration, or the environment and software stack that it runs on. Manual testing is also an essential part of building quality in: Showcases, usability testing, and exploratory testing need to be done continuously throughout the project. Building quality in also means constantly working to improve your automated testing strategy."
  },
  {
    "paragraph": "Acceptance tests are critical in an agile environment because they answer the questions, “How do I know when I am done?” for developers and “Did I get what I wanted?” for users"
  },
  {
    "paragraph": "Acceptance tests should be run when your system is in a production-like mode."
  },
  {
    "paragraph": "Regression tests represent the entire corpus of your automated tests. They serve to ensure that when you make a change you don’t break existing functionality."
  },
  {
    "paragraph": "Many organizations use canary releasing (see the “Canary Releasing” section on page 263) where several subtly different versions of the application are in production simultaneously and their effectiveness is compared."
  },
  {
    "paragraph": "Legacy systems: Test the code that you change. The first priority when dealing with such a system is to create an automated build process if one doesn’t exist, and then create an automated functional test scaffolding around it. Creating an automated test suite will be easier if documentation, or better still, members of the team who worked on the legacy system are available. However, this is often not the case."
  },
  {
    "paragraph": "a staging environment is a testing environment identical to the production environment"
  },
  {
    "paragraph": "The code will be compiled repeatedly in different contexts: during the commit process, again at acceptance test time, again for capacity testing, and often once for each separate deployment target. Every time you compile the code, you run the risk of introducing some difference. The version of the compiler installed in the later stages may be different from the version that you used for your commit tests."
  },
  {
    "paragraph": "Recompiling violates this principle because it takes time, especially in large systems."
  },
  {
    "paragraph": "When you deploy your application, you should have an automated script that does a smoke test to make sure that it is up and running. This could be as simple as launching the application and checking to make sure that the main screen comes up with the expected content."
  },
  {
    "paragraph": "But the most fundamental one was that unit tests only test a developer’s perspective of the solution to a problem. They have only a limited ability to prove that the application does what it is supposed to from a users perspective"
  },
  {
    "paragraph": "Crucially, the development team must respond immediately to acceptance test breakages that occur as part of the normal development process."
  },
  {
    "paragraph": "The reality is that the whole team owns the acceptance tests, in the same way as the whole team owns every stage of the pipeline. If the acceptance tests fail, the whole team should stop and fix them immediately."
  },
  {
    "paragraph": "The less control we have over the environment in which our code executes, the more potential there is for unexpected behaviors."
  },
  {
    "paragraph": "frequent release into production—a process we recommend very strongly when it is applicable"
  },
  {
    "paragraph": "you could start with a bare minimum: a commit stage to build your application and run basic metrics and unit tests, a stage to run acceptance tests, and a third stage to deploy your application to a production-like environment so you can demo it."
  },
  {
    "paragraph": "To tame some of this complexity, a common convention adopted by teams working on large codebases is to create a Makefile for each directory, and have a top-level Makefile that recursively runs the Makefiles in each subdirectory."
  },
  {
    "paragraph": "When you first start your project, it makes sense to have a single script containing every operation that will be performed in the course of executing the deployment pipeline, with dummy targets for steps that are not yet automated."
  },
  {
    "paragraph": "The most common mistake in a build is to use absolute paths by default."
  },
  {
    "paragraph": "Your default should be to use relative paths for everything."
  },
  {
    "paragraph": "The general rule of thumb is not to check in anything created as part of your build, test, and deploy cycle into source control."
  },
  {
    "paragraph": "The principal goal of the commit stage is to either create deployable artifacts, or fail fast and notify the team of the reason for the failure."
  },
  {
    "paragraph": "If that developer has been following our advice and committing changes frequently, the scope of each change will be small. If the deployment pipeline is able to identify that failure quickly, ideally at the commit stage, then the scope of the change is limited to those changes made personally by the developer This means that fixing the problems found in the commit stage is significantly simpler than those identified later in the process, in stages that may be testing a larger number of changes batched together."
  },
  {
    "paragraph": "The commit stage should be focused on one thing: detecting, as fast as possible, the most common failures that changes to the system may introduce, and notifying the developers so they can fix the problems quickly"
  },
  {
    "paragraph": "The commit stage of your deployment pipeline should be run every time someone introduces a change into your application’s code or configuration. Thus it will be exercised multiple times each day by each member of your development team. The natural tendency of developers is to complain if the performance of the build falls below an acceptable standard: Let it grow to over five minutes and the complaints will start"
  },
  {
    "paragraph": "it is more important to have a comprehensive automated test suite than one that runs in ten minutes."
  },
  {
    "paragraph": "When the isolation of your acceptance tests is good, another possibility to speed things up presents itself: running the tests in parallel"
  },
  {
    "paragraph": "we generally prefer to avoid capacity testing through the UI"
  },
  {
    "paragraph": "A zero-downtime release, also known as hot deployment, is one in which the actual process of switching users from one release to another happens nearly instantaneously. Crucially, it must also be possible to back users out to the previous version nearly instantaneously too, if something goes wrong."
  },
  {
    "paragraph": "if it hurts, do it more often"
  },
  {
    "paragraph": "Continuous deployment isn’t for everyone. Sometimes, you don’t want to release new features into production immediately. In companies with constraints on compliance, approvals are required for deployments to production."
  },
  {
    "paragraph": "A good practice in the UNIX world is to deploy each version of the application into a new directory and have a symbolic link that points to the current version."
  },
  {
    "paragraph": "A “build and deployment expert” is an antipattern. Every member of the team should know how to deploy, and every member of the team should know how to maintain the deployment scripts. This can be achieved by making sure that every time you build the software, even on a developers machine, it uses the real deployment scripts."
  },
  {
    "paragraph": "The most effective mechanism to migrate data in an automated fashion is to version your database. Simply create a table in your database that contains its version number. Then, every time you make a change to the database, you need to create two scripts: one that takes the database from a version x to version x + 1 (a roll-forward script), and one that takes it from version x + 1 to version x (a roll-back script). You will also need to have a configuration setting for your application specifying the version of the database it is designed to work with (this can be kept as a constant in version control and updated every time a database change is required)."
  },
  {
    "paragraph": "In our projects, we will often isolate the code creating test instances of such commonly used data structures and share them between many different test cases. We may have a CustomerHelper or CustomerFixture class that will simplify the creation of Customer objects for our tests, so they are created in a consistent manner with a collection of standard default values for each Customer"
  },
  {
    "paragraph": "One solution is to put in the new features, but make them inaccessible to users."
  },
  {
    "paragraph": "The most important property of an artifact repository is that it should not contain anything that cannot be reproduced."
  },
  {
    "paragraph": "The main purpose of branch. So if you merge your branch to (not just from) mainline once a day, you’re OK. If you’re not doing that, you’re not doing continuous integration"
  },
  {
    "paragraph": "s is to facilitate parallel development: the ability to work on two or more work streams at the same time without one affecting the other."
  },
  {
    "paragraph": "So if you merge your branch to (not just from) mainline once a day, you’re OK. If you’re not doing that, you’re not doing continuous integration"
  },
  {
    "paragraph": "It’s worth saying again: You should never use long-lived, infrequently merged branches as the preferred means of managing the complexity of a large project."
  },
  {
    "paragraph": "Iterations are no longer than two weeks."
  },
  {
    "paragraph": "Like most things, things get worse before they get better."
  },
  {
    "paragraph": "Perfection is the enemy of good."
  },
  {
    "paragraph": "“A great team doesn’t mean that they had the smartest people. What made those teams great is that everyone trusted one another. It can be a powerful thing when that magic dynamic exists."
  },
  {
    "paragraph": "Steve continues, “One of my favorite books about team dynamics is Five Dysfunctions of a Team, by Patrick Lencioni. He writes that in order to have mutual trust, you need to be vulnerable. So, I’m going to tell you a little about myself and what makes me tick. And then I’m going to ask you to do the same."
  },
  {
    "paragraph": "Studies have shown that practicing five minutes daily is better than practicing once a week for three hours."
  },
  {
    "paragraph": "Our view is that a complex problem is really just a collection of smaller, simpler problems waiting to be solved. Making big problems small, and in so doing achieving big results with less work."
  },
  {
    "paragraph": "Overengineering is one of the many enemies of scale. Developing a solution beyond that which is useful simply wastes money and time. It may further waste processing resources, increase the cost of scale, and limit the overall scalability of the system (how far that system can be scaled). Building solutions that are overly complex has a similar effect. Systems that work too hard increase your cost and limit your ultimate size. Systems that make users work too hard limit how quickly you are likely to increase the number of users and therefore how quickly you will grow your business. Systems that are too complex to understand kill organizational productivity and the ease with which you can add engineers or add functionality to your system."
  },
  {
    "paragraph": "Design for 20x capacity. n"
  },
  {
    "paragraph": "Implement for 3x capacity."
  },
  {
    "paragraph": "Deploy for roughly 1.5x capacity."
  },
  {
    "paragraph": "If you cut unnecessary features from your product, you can do five times as much work, and your product will be significantly less complex! By simplifying our scope, we have more computational power because we are doing less."
  },
  {
    "paragraph": "Complexity elimination is about cutting off unnecessary trips in a job, and simplification is about finding a shorter path."
  },
  {
    "paragraph": "The simplest implementation is almost always one that has already been implemented and proven scalable."
  },
  {
    "paragraph": "The Domain Name System (DNS) is one of the most important parts of the infrastructure of the Internet or any other network that utilizes the Internet Protocol Suite (TCP/IP). It allows the translation from domain name (www.akfpartners.com) to an IP address (184.72.236.173) and is often analogized to a phone book. DNS is maintained by a distributed database system, the nodes of which are called name servers. The top of the hierarchy consists of the root name servers. Each domain has at least one authoritative DNS server that publishes information about that domain."
  },
  {
    "paragraph": "This process of translating domains into IP addresses is made quicker by caching on many levels, including the browser, computer operating system, Internet service provider, and so on. While caching significantly improves the performance of name resolution, today’s pages can have hundreds or even thousands of objects served from multiple domains. Each domain requires a name resolution, and these resolution requests can add up to time that’s noticeable to the consumer."
  },
  {
    "paragraph": "As a general rule, the fewer DNS lookups on your pages, the better your page download performance will be. There is a downside to combining all your objects into a single domain, and we’ve hinted at the reason in the previous discussion about maximum simultaneous connects."
  },
  {
    "paragraph": "Now we need to think about breaking these objects up into a number of smaller ones that can be downloaded simultaneously. One final variable to add to the equation is that part we mentioned about simultaneous persistent connections per server, which will bring us full circle to our DNS discussion noted in Rule 4."
  },
  {
    "paragraph": "The client that we talked about earlier who was in the online magazine industry and had a 12-second page load time used this technique across seven subdomains and was able to reduce the average load time to less than 5 seconds."
  },
  {
    "paragraph": "Leaner (smaller) is almost always faster"
  },
  {
    "paragraph": "It is always wise to make a page as light as possible to achieve the desired result. And where pages must be heavy, implement Gzip compression to reduce the page weight transferred and ideally the total response time of the page."
  },
  {
    "paragraph": "One technique for scaling databases is to take advantage of the fact that most applications and databases perform significantly more reads than writes. A client of ours that handles booking reservations for customers has on average 400 searches for a single booking. Each booking is a write and each search a read, resulting in a 400:1 read-to-write ratio. This type of system can be easily scaled by creating read-only copies (or replicas) of the data."
  },
  {
    "paragraph": "Now that we’ve covered the time sensitivity, let’s start discussing the ways to distribute the data. One way is to use a caching tier in front of the database. An object cache can be used to read from instead of going back to the application for each query. Only when the data has been marked expired would the application have to query the primary transactional database to retrieve the data and refresh the cache. We highly recommend this as a first step given the availability of numerous excellent, open-source key-value stores that can be used as object caches."
  },
  {
    "paragraph": "The next step beyond an object cache between the application tier and the database tier is replicating the database. Most major relational database systems allow for some type of replication “out of the box.” Many databases implement replication through some sort of master-slave concept—the master database being the primary transactional database that gets written to, and the slave databases being read-only copies of the master database."
  },
  {
    "paragraph": "Having the ability to run your product on multiple servers through all tiers is scaling out. Continuing to run your systems on larger hardware at any tier is scaling up"
  },
  {
    "paragraph": "“When all you have is a hammer, everything looks like a nail.”"
  },
  {
    "paragraph": "Using the right tool for the right job at the right time"
  },
  {
    "paragraph": "Use relational databases when you need ACID properties to maintain relationships between your data and consistency. For other data storage needs consider more appropriate tools such as NoSQL DBMSs. An RDBMS provides great transactional integrity but is more difficult to scale, costs more, and has lower availability than many other storage options. Because of this guarantee of ACID properties, an RDBMS can be more challenging to scale than other data stores."
  },
  {
    "paragraph": "File systems are great alternatives when you have a “write once, read many” system. Put another way, if you don’t expect to have conflicting reads and writes over time on a structure or object and you don’t need to maintain a large number of relationships, you don’t really need the transactional overhead of a database; file systems are a great choice for this kind of work."
  },
  {
    "paragraph": "Read and write ratios are important as they help drive an understanding of what kind of system we need. Data that is written once and read many times can easily be put on a file system coupled with some sort of application, file, or object cache. Images are great examples of systems that typically can be put on file systems."
  },
  {
    "paragraph": "Logs provide powerful insights into the performance and errors occurring within your application that might prevent it from scaling."
  },
  {
    "paragraph": "The first step in using log files is to aggregate them. As you probably have dozens or perhaps even hundreds of servers, you need to pull this data together to use it. If the amount of data is too large to pull together, there are strategies such as sampling, pulling data from every nth server, that can be implemented."
  },
  {
    "paragraph": "Redirects in general delay the user, consume computation resources, are prone to errors, and can negatively affect search engine rankings. A few of the reasons to avoid redirection when possible are that it always delays users from getting the resource they want, it takes up computational resources, and there are many ways to break redirection, hurting user browsing or search engine rankings."
  },
  {
    "paragraph": "Consistency— The client perceives that a set of operations has occurred all at once."
  },
  {
    "paragraph": "Availability—Every operation must terminate in an intended response."
  },
  {
    "paragraph": "Partition tolerance—Operations will complete, even if individual components are unavailable."
  },
  {
    "paragraph": "To solve latency and scale issues, the first thing Lon’s team did was to add a content distribution network; they chose Akamai. Lon stated, “It was really simple to just take all of our static assets and push them there [Akamai] and let them handle caching closest to the user."
  },
  {
    "paragraph": "CDNs are a collection of computers, called nodes or edge servers, connected via a network, called a backbone, that have duplicate copies of their customers’ data or content (images, Web pages, and so on) on them"
  },
  {
    "paragraph": "Use Expires headers to reduce requests and improve the scalability and performance of your system."
  },
  {
    "paragraph": "If you have the ability to postpone the split of a database or the purchase of a larger server, which is not a recommended approach to scaling, by implementing an object cache this is an easy decision."
  },
  {
    "paragraph": "Research has long supported the position that we learn more from our failures than from our successes. But we can only truly learn from our failures if we foster an environment of open, honest communication and fold in lightweight processes that help us repeatedly learn and get the most from our mistakes and failures. Rather than emulate the world of politics, where failures are hidden from others and as a result bound to be repeated over time, we should strive to create an environment in which we share our failures as antipatterns to best practices. To be successful, we need to learn aggressively by watching customers and treating each failure as a learning opportunity, rely on organizations like QA appropriately, expect systems to fail, and design for those failures appropriately. The following story illustrates how one company was able to learn both deeply and broadly."
  },
  {
    "paragraph": "Take every opportunity, especially failures, to learn and teach important lessons."
  },
  {
    "paragraph": "Doing something without measuring the results or having an incident without learning from it are wasted opportunities that your competitors are taking advantage of. We learn best from our mistakes—not our successes."
  },
  {
    "paragraph": "Our philosophy is that while mistakes are unavoidable, making the same mistake twice is unacceptable."
  },
  {
    "paragraph": "Ensure that all releases have the ability to roll back, practice it in a staging or QA environment, and use it in production when necessary to resolve customer incidents."
  },
  {
    "paragraph": "Database changes must only be additive—Columns or tables should only be added, not deleted, until the next version of code is released that deprecates the dependency on those columns."
  },
  {
    "paragraph": "The cost of fixing a broken data model after it has been implemented is likely 100x as much as fixing it during the design phase."
  },
  {
    "paragraph": "Don’t use Select * in queries."
  },
  {
    "paragraph": "As a best practice, do not get in the habit of using Select or Insert without specifying the columns. Besides wasting resources and being likely to break or potentially even corrupt data, it also prevents you from rolling back."
  },
  {
    "paragraph": "Swim lane is a term used to identify a fault isolation domain."
  },
  {
    "paragraph": "In mathematics, singletons are sets that have only one element {A}. In programming parlance, the singleton pattern is a design pattern that mimics the mathematical notion and restricts the instantiation of a class to only one object"
  },
  {
    "paragraph": "when you have a stateful system and something fails, now you have some real problems. How do you recover that state? How long are you willing to wait to allow it to fully recover?"
  },
  {
    "paragraph": "Another very serious con that was brought to light by the Firefox plug-in Firesheep is that session data can be easily captured on an open WiFi network and used to nefariously log in to someone else’s account. With the aforementioned plug-in, session cookies from most of the popular sites such as Google, Facebook, Twitter, and Amazon, just to name a few, can be compromised. A little later we suggest a way to protect your users’ cookies against this type of hack or attack, commonly called sidejacking."
  },
  {
    "paragraph": "For ultimate scalability we recommend avoiding sessions altogether. However, this isn’t always possible. In these cases we recommend storing the session data in the user’s browser"
  },
  {
    "paragraph": "Asynchronous systems tend to scale more easily and tend to be more highly available than synchronous systems"
  },
  {
    "paragraph": "RFM. Recency accounts for how recently the data item in question has been accessed. This might be a file in your storage system or rows within a database. Frequency speaks to how frequently that data is accessed. Sometimes this is captured as the mean period between access and the rough inverse of this—the number of accesses over some time interval. Monetization is the value that a specific piece of data has to your business in general. When applied to data, these three terms help us calculate overall business value and access speeds."
  },
  {
    "paragraph": "downtime (the amount of time your service is unavailable)"
  },
  {
    "paragraph": "Stateful Stream Processing: Virtually all data is created as continuous streams of events. Think of user interactions on websites or in mobile apps, placements of orders, server logs, or sensor measurements; all of these are streams of events."
  },
  {
    "paragraph": "Operators without input ports are called data sources and operators without output ports are called data sinks. A dataflow graph must have at least one data source and one data sink."
  },
  {
    "paragraph": "Latency indicates how long it takes for an event to be processed."
  },
  {
    "paragraph": "Throughput is a measure of the system’s processing capacity—its rate of processing. That is, throughput tells us how many events the system can process per time unit"
  },
  {
    "paragraph": "If the system continues to receive data at a higher rate than it can handle, buffers might become unavailable and data might get lost. This situation is commonly known as backpressure"
  },
  {
    "paragraph": "Data ingestion is the operation of fetching raw data from external sources and converting it into a format suitable for processing. Operators that implement data ingestion logic are called data sources. A data source can ingest data from a TCP socket, a file, a Kafka topic, or a sensor data interface. Data egress is the operation of producing output in a form suitable for consumption by external systems. Operators that perform data egress are called data sinks and examples include files, databases, message queues, and monitoring interfaces."
  },
  {
    "paragraph": "Extract duplication only when you see it for the third time."
  },
  {
    "paragraph": "Duplication is far easier to refactor than the wrong abstraction."
  },
  {
    "paragraph": "If your test names express business behaviors, when you change the technical implementation or refactor code, your test names should remain unchanged."
  },
  {
    "paragraph": "Tests should test one thing only."
  },
  {
    "paragraph": "Avoid technical names for tests. Example: myMethodNameReturnsSomething"
  },
  {
    "paragraph": "Avoid leaking implementation details in test names Example: myTestReturnsFalse or CommandPatternTest"
  },
  {
    "paragraph": "Avoid writing technical tests; you should test behaviors, not the technicality of components."
  },
  {
    "paragraph": "If you need something once, build it. If you need something twice, pay attention. If you need it a third time, abstract it. Keep in mind that duplication is easier to tackle than the wrong abstractions."
  },
  {
    "paragraph": "Like most developers starting TDD, I encountered a common blocker: coming up with good test names. With experience and a little help from other programmers, I learned to not reach for the test name too soon. I give the test a temporary name; foo is a fine name. Then I concentrate on what the assertion should look like for the behavior I’m testing. Once I get the assertion right, I need to think how I get there. Once I have all this, naming the test becomes so much easier."
  },
  {
    "paragraph": "Perfection (in design) is achieved not when there is nothing more to add, but rather when there is nothing more to take away.” Antoine de Saint-Exupery"
  },
  {
    "paragraph": "Keep all entities small"
  },
  {
    "paragraph": "• 10 files per package"
  },
  {
    "paragraph": "• 50 lines per class"
  },
  {
    "paragraph": "• 5 lines per method"
  },
  {
    "paragraph": "• 2 arguments per method"
  },
  {
    "paragraph": "To improve readability, you should start with better names for variables, methods and classes. The idea is to express intent rather than implementation details."
  },
  {
    "paragraph": "Delete dead code. Don’t make the reader waste time trying to figure out code that is not in use anymore."
  },
  {
    "paragraph": "MessageChains–Toomanydots:Dog.Body.Tail.Wag()Shouldbe:Dog.ExpressHappiness(). “One dot per line” object calisthenics rule violation."
  },
  {
    "paragraph": "Don’t use primitive types as substitutes for classes. If the data type is sufficiently complex, use a class to represent it."
  },
  {
    "paragraph": "Functions that change state should not return values and functions that return values should not change state.” Bertrand Meyer, Object-Oriented Software Construction"
  },
  {
    "paragraph": "A Test Double is any kind of object used in place of a real object for testing purposes."
  },
  {
    "paragraph": "Queries A query is a method call that returns data and shouldn’t have any effect on the state of an object. (They should be idempotent)."
  },
  {
    "paragraph": "Mocks are all about verifying the occurrence of a behavior"
  },
  {
    "paragraph": "Mocks are set up with expectations of the calls they are expected to receive."
  },
  {
    "paragraph": "Mock objects might also be Stubs, but should not add any additional complexity to the test environment. Their behavior should be obvious and self-explanatory."
  },
  {
    "paragraph": "“Don’t change production code that is not covered by tests. If we need to refactor some code that has no tests, then start by adding behavior tests.”"
  },
  {
    "paragraph": "when I think of design patterns, I don’t even remember the solution – I remember the problems they are meant to solve. For anything else we have Google (or DuckDuckGo)."
  },
  {
    "paragraph": "“Write programs that do one thing and do it well. Write programs to work together.”"
  },
  {
    "paragraph": "Composition expresses the concept of “has a”"
  },
  {
    "paragraph": "inheritance represents the “is a” relationships"
  },
  {
    "paragraph": "Many people try to come up with a great name all at once. This is hard and rarely works well. The problem is that naming is design: it is picking the correct place for each thing and creating the right abstraction. Doing that perfectly the first time is unlikely."
  },
  {
    "paragraph": "Acceptance criteria defines “what needs to be done” and acceptance tests define “how it should be done.” Acceptance tests are organized similar to the arrange-act-assert sections of a unit test. However, in acceptance tests, these sections are usually known as give-when-then. (Given) some context, (When) some action is carried out, (Then) a set of consequences should happen."
  },
  {
    "paragraph": "Communication is one of the most important aspects of every organization, and it is crucial for the success of projects. So, handling information through too many lines raises the chance of misunderstanding"
  },
  {
    "paragraph": "software development is a team activity. Success and failure is team success or failure."
  },
  {
    "paragraph": "we can say that knowledge answers the question “what” about something, while understanding answer the question “why.”"
  },
  {
    "paragraph": "“Software projects fail when you don’t understand the business domain you are working within well enough. Typing is not the bottleneck for delivering a product; coding is the easy part of development. [...] [C]reating and keeping a useful software model of the domain that can fulfill business-use cases is the difficult part. However, the more you invest in understanding your business domain the better equipped you will be when you are trying to model it in software to solve its inherent business problems.”"
  },
  {
    "paragraph": "Collaboration with domain experts is at the core of DDD, which coined the term “knowledge crunching” to express it. “Knowledge crunching is the art of distilling relevant information from the problem domain in order to build a useful model that can fulfill the needs of business use cases.”"
  },
  {
    "paragraph": "In our experience, we have found that the best way to achieve understanding is by asking questions. Never be afraid to ask questions. One of the most powerful questions to ask for reaching understanding is very simple: WHY?"
  },
  {
    "paragraph": "From this point-of-view, synchronous dependencies between services imply that the calling service blocks the execution and waits for a response from the called service before continuing. Very similar to the concepts of Connascence of Execution Order and Connascence of Timing, this kind of dependency is very strong, tightly coupling the caller with the called. It does not scale very well, and the calling service may be impacted by errors in the called service. In systems with high availability as one of the non-functional requirements, this kind of communication is not desired. A powerful alternative to the synchronous approach is asynchronous communication using a publish/subscribe messaging system. In this scenario, the calling service simply publishes its message about a domain event occurring and continues with other work (unrelated to this request). It is not blocking and waiting for a response after it sends a request, and this improves scalability. Problems in another service do not break this service, and when other services are temporarily broken, the calling service might not be able to complete a process completely, but the calling service is not broken itself. Thus, using asynchronous messaging, the services are more decoupled, preserving more autonomy. The downside of the asynchronous messaging solution is that it increases the infrastructural complexity of the system because it requires mechanisms to send and handle messages. Furthermore, the design of the flow of domain events becomes essential when this pattern is used heavily, and this can move complexity into an area that is very difficult to monitor, opening the door for unwanted risks"
  },
  {
    "paragraph": "Remember, with great power comes great responsibility."
  },
  {
    "paragraph": "What a childish concept; it wasn’t my code or his code – it was ours."
  },
  {
    "paragraph": "Software development is a learning process, working code is a side effect."
  },
  {
    "paragraph": "One of the things I see people having the hardest time with is the idea that microser‐ vices should not share databases. If one service wants to access data held by another service, then it should go and ask that service for the data it needs. This gives the ser‐ vice the ability to decide what is shared and what is hidden. It also allows the service to map from internal implementation details, which can change for various arbitrary reasons, to a more stable public contract, ensuring stable service interfaces. Having stable interfaces between services is essential if we want independent deployability—if the interface a service exposes keeps changing, this will have a ripple effect causing other services to need to change as well."
  },
  {
    "paragraph": "Don’t share databases, unless you really have to. And even then do everything you can to avoid it. In my opinion, it’s one of the worst things you can do if you’re trying to achieve independent deploya‐ bility."
  },
  {
    "paragraph": "If you know PHP best, start building services with PHP!1 Don’t be part of the problem! Choose the approach that works for you, and change things to address problems as and when you see them."
  },
  {
    "paragraph": "Coupling speaks to how changing one thing requires a change in another; cohesion talks to how we group related code"
  },
  {
    "paragraph": "Smaller releases make for less risk. There is less to go wrong. If something does go wrong, working out what went wrong and how to fix it is easier because we changed less. Finding ways to reduce the size of release goes to the heart of continuous delivery, which espouses the importance of fast feedback and release-on-demand methods. The smaller the scope of the release, the easier and safer it is to roll out, and the faster feedback we’ll get. My own interest in microservices comes from a pre‐ vious focus on continuous delivery—I was looking for architectures that made adop‐ tion of continuous delivery easier."
  },
  {
    "paragraph": "Bounded contexts hide implementation detail."
  },
  {
    "paragraph": "microservices are independently deployable serv‐ ices modeled around a business domain. They communicate with each other via net‐ works. We use the principles of information hiding together with domain-driven design to create services with stable boundaries that are easier to work on independ‐ ently, and we do what we can to reduce the many forms of coupling."
  },
  {
    "paragraph": "You should be thinking of migrating to a microservice architecture in order to achieve something that you can’t currently achieve with your existing sys‐ tem architecture."
  },
  {
    "paragraph": "You also risk falling into a cargo cult mentality, just assuming that “If microservices are good for Netflix, they’re good for us!”"
  },
  {
    "paragraph": "A real startup is likely a small organization with limited funding, which needs to focus all its attention on finding the right fit for its product. Microservices primarily solve the sorts of problems startups have once they’ve found that fit with their cus‐ tomer base. Put a different way, microservices are a great way of solving the sorts of problems you’ll get once you have initial success as a startup. So focus initially on being a success!"
  },
  {
    "paragraph": "Doing microservices just because everyone else is doing it is a terrible idea."
  },
  {
    "paragraph": "Trust is earned."
  },
  {
    "paragraph": "Focusing initially on small, easy, low-hanging fruit will help build momentum."
  },
  {
    "paragraph": "Once you’ve got some success, it becomes important not to sit on your laurels. Quick wins might be the only wins if you don’t continue to push on. It’s important you pause and reflect after successes (and failures) so you can think about how to keep driving the change."
  },
  {
    "paragraph": "If you do a big-bang rewrite, the only thing you’re guaranteed of is a big bang. —Martin Fowler"
  },
  {
    "paragraph": "If you make a small change, it’s much easier to spot (and fix) a problem you create."
  },
  {
    "paragraph": "Take inspiration from what other organizations have done, absolutely, but don’t assume that what worked for someone else will work in your context."
  },
  {
    "paragraph": "The right answer could be to bring new people into the team that have the skills you need. Rather than helping the developers learn more about Kafka, you could hire a Kafka expert to join your team. This could solve the short-term problem, and you then have an in-team expert who can help their colleagues learn more in this area too."
  },
  {
    "paragraph": "Mistakes are inevitable, so if accepting that as a given, you should aim to make small mistakes rather than big ones. Breaking a transi‐ tion to a microservice architecture into small incremental steps ensures that the mis‐ takes we make will be small and easier to recover from."
  },
  {
    "paragraph": "In the context of software, the parallel here is to have our new system initially be sup‐ ported by, and wrapping, the existing system. The idea is that the old and the new can coexist, giving the new system time to grow and potentially entirely replace the old system. The key benefit to this pattern, as we’ll see shortly, is that it supports our goal of allowing for incremental migration to a new system. Moreover, it gives us the abil‐ ity to pause and even stop the migration altogether, while still taking advantage of the new system delivered so far."
  },
  {
    "paragraph": "NGINX allows you to use code written in Lua to add custom behavior."
  },
  {
    "paragraph": "When migrating functionality, try to eliminate any changes in the behavior being moved—delay new features or bug fixes until the migration is complete if you can. Otherwise, you may reduce your ability to roll back changes to your system."
  },
  {
    "paragraph": "trunk-based development (where changes are made directly on the main line and branches are avoided)"
  },
  {
    "paragraph": "One of the real problems associated with the use of feature flags is leaving old ones lying around—don’t do that! Remove flags you don’t need anymore to keep things simple."
  },
  {
    "paragraph": "I think direct sharing of a database is appropriate for a microservice architecture in only two situations. The first is when considering read-only static reference data."
  },
  {
    "paragraph": "Keep schema separation where you think you may have service separation in the future"
  },
  {
    "paragraph": "If your microservices use shared libraries, remember that you have to accept that you might have different versions of the library deployed in production!"
  },
  {
    "paragraph": "Strongly consider implementing log aggregation as the first thing you do before implementing a microservice architecture. It’s incredibly useful, and is a good test of your organization’s ability to implement change in the operational space. I suggest it’s the first thing you should do when imple‐ menting a microservice architecture."
  },
  {
    "paragraph": "Names should explain things in the terms of the context they are in, not the caller’s."
  },
  {
    "paragraph": "Validate early, and return as early as possible. Put the exceptional cases inside if statements and try to put your happy path outside of the blocks."
  },
  {
    "paragraph": "Tests assure you that a fixed bug will remain fixed and it won’t appear again. Every time you fix a bug, adding a test for it, will make sure you won’t have to deal with that bug again, ever. Otherwise, who knows when another change won’t trigger it again? Tests are critical timesavers when used like that."
  },
  {
    "paragraph": "One of my managers had this manual technique to ensure that his team wrote reliable tests: He removed random lines of code from the production code and ran the test again. If your tests passed, that meant you failed."
  },
  {
    "paragraph": "Concurrency measures how many clients your system can serve at the same time."
  },
  {
    "paragraph": "Performance measures how long it takes to process a request or to perform a certain task, whereas scalability measures how much we can grow (or shrink)."
  },
  {
    "paragraph": "GeoDNS is a DNS service that allows domain names to be resolved to IP addresses based on the location of the customer."
  },
  {
    "paragraph": "Edge cache is a HTTP cache server located near the customer, allowing the customer to partially cache the HTTP traffic."
  },
  {
    "paragraph": "Overengineering usually happens when people try to do the right thing, but choose the wrong perspective or assume too much about future needs. I encourage you to ask yourself “What tradeoffs am I making here?” or “Will I really need this?” and work closely with the business stakeholders to better understand the biggest risks and unknowns."
  },
  {
    "paragraph": "Coupling is a measure of how much two components know about and depend on one another. The higher the coupling, the stronger the dependency. Loose coupling refers to a situation where different components know as little as necessary about each other, whereas no coupling between components that they are completely unaware of each other’s existence."
  },
  {
    "paragraph": "When designing a class, first consider what functionality your clients really need and then define the minimal interface as the contract."
  },
  {
    "paragraph": "Drawing diagrams is a must-have skill for every architect and technical leader. Diagrams summarize knowledge, and they truly are worth a thousand words."
  },
  {
    "paragraph": "Promoting Single Responsibility"
  },
  {
    "paragraph": "Keep class length below two to four screens of code."
  },
  {
    "paragraph": "Ensure that a class depends on no more than five other interfaces/classes."
  },
  {
    "paragraph": "Ensure that a class has a specific goal/purpose."
  },
  {
    "paragraph": "Summarize the responsibility of the class in a single sentence and put it in a comment on top of the class name. If you find it hard to summarize the class responsibility, it usually means that your class does more than one thing."
  },
  {
    "paragraph": "Inversion of control (IOC) is a method of removing responsibilities from a class to make it simpler and less coupled to the rest of the system. At its core, inversion of control is not having to know who will create and use your objects, how, or when. It is about being as dumb and oblivious as possible, as having to know less is a good thing for software design."
  },
  {
    "paragraph": "In short, keep all your web servers stateless, both front-end web and web service servers. Keeping servers stateless will let you scale them easily by adding more clones."
  },
  {
    "paragraph": "CAP theorem which stated that it was impossible to build a distributed system that would simultaneously guarantee consistency, availability, and partition tolerance. In this theorem, a distributed system consists of nodes (servers) and network connections allowing nodes to talk to each other. Consistency ensures that all of the nodes see the same data at the same time. Availability guarantees that any available node can serve client requests even when other nodes fail. Finally, partition tolerance ensures that the system can operate even in the face of network failures where communication between nodes is impossible."
  },
  {
    "paragraph": "Always consider ways to reduce the number of possible cache keys. The fewer cache keys possible, the better for your cache efficiency."
  },
  {
    "paragraph": "Bundling CSS and JS files and publishing them under unique URLs gives you two important benefits: your static files can be cached forever by any caches (browsers, proxies, and CDN servers), and you can have multiple versions of the same file available to your clients at any point in time. This allows you to maximize your cache hit ratio and makes deploying new code much easier. If you deployed a new version of the JavaScript file by replacing an existing URL, some clients who have an old version of the HTML page might load the new JavaScript file and get errors. By releasing new versions of static files under new URLs, you guarantee that users can always download compatible versions of HTML, CSS, and JavaScript files."
  },
  {
    "paragraph": "A content delivery network (CDN) is a distributed network of cache servers that work in a similar way as caching proxies."
  },
  {
    "paragraph": "One of the most important things to remember about caching is that the higher up the call stack you can cache, the more resources you can save."
  },
  {
    "paragraph": "If you can cache an entire page fragment, you will save more time and resources than caching just the database query that was used to render this page fragment."
  },
  {
    "paragraph": "Engineers tend to think alike, and they often create similar solutions to similar problems. When the solution proves to be successful over and over again, we call it a pattern, but when the solution is repeatedly difficult to maintain or extend, we call it an anti-pattern. A typical anti-pattern is a solution that seems like a good idea at first, but the longer you use it, the more issues you discover with it. By getting familiar with anti-patterns, you should be able to easily avoid them in the future—it is like getting a vaccination against a common design bug."
  },
  {
    "paragraph": "Hope for the best, prepare for the worst."
  },
  {
    "paragraph": "Lean Startup advocates minimal viable product (MVP) development and a quick feedback loop."
  },
  {
    "paragraph": "An exchange is just an abstract named endpoint to which publishers address their messages. Publishers do not have to know topic names or queue names as they publish messages to exchanges. Consumers, on the other hand, consume messages from queues."
  },
  {
    "paragraph": "Publishers have to know the location of the message broker and the name of the exchange, but they do not have to know anything else. Once a message is published to an exchange, RabbitMQ applies routing rules and sends copies of the message to all applicable queues. Once messages appear in queues, consumers can consume them without knowing anything about exchanges."
  },
  {
    "paragraph": "First of all, to understand EDA (event driven arch), you need to stop thinking about software in terms of requests and responses. Instead, you have to think about components announcing things that have already happened."
  },
  {
    "paragraph": "A full table scan is often the term used for this type of search, as you need to scan the entire data set to find the row that you are looking for."
  },
  {
    "paragraph": "Big O notation is a way to compare algorithms and estimate their cost. In simple terms, Big O notation tells you how the amount of work changes as the size of the input changes. Imagine that n is the number of rows in your data set (the size) and the Big O notation expression estimates the cost of executing your algorithm over that data set. When you see the expression O(n), it means that doubling the size of the data set roughly doubles the cost of the algorithm execution. When you see the expression O(n^2), it means that as your data set doubles in size, the cost grows quadratically (much faster than linear)."
  },
  {
    "paragraph": "A compound index, also known as a composite index, is an index that contains more than one field. You can use compound indexes to increase search efficiency where cardinality or distribution of values of individual fields is not good enough."
  },
  {
    "paragraph": "To be able to model data in NoSQL data stores and access it efficiently, you need to change the way you design your schema. Rather than starting with data in mind, you need to start with queries in mind"
  },
  {
    "paragraph": "An inverted index is a type of index that allows you to search for phrases or individual words (full text search)."
  },
  {
    "paragraph": "With the safety net of automated tests, your teams can become what Robert C. Martin calls fearless engineers. Fearless engineers are not afraid to make changes. They control their software and they have legitimate confidence that bugs are detected before they make their way into production."
  },
  {
    "paragraph": "Key-value data stores: Dynamo and Riak"
  },
  {
    "paragraph": "Document oriented data stores: MongoDB, CouchDB, and Couchbase"
  },
  {
    "paragraph": "Wide columnar data stores: BigTable, Cassandra, and HBase."
  },
  {
    "paragraph": "By staying close to our users and by showing them progress in small pieces, we had found a way to be successful without the beautiful requirements documents."
  },
  {
    "paragraph": "Software requirements is a communication problem."
  },
  {
    "paragraph": "the key is that stories should be written so that the customer can value them."
  },
  {
    "paragraph": "it is better to have more stories than to have stories that are too large."
  },
  {
    "paragraph": "Rather than writing all these details as stories, the better approach is for the development team and the customer to discuss these details."
  },
  {
    "paragraph": "the developers will estimate how much work they'll be able to do per iteration. We call this velocity."
  },
  {
    "paragraph": "A release is made up of one or more iterations."
  },
  {
    "paragraph": "Acceptance testing is the process of verifying that stories were developed such that each works exactly the way the customer team expected it to work."
  },
  {
    "paragraph": "Dependencies between stories lead to prioritization and planning problems."
  },
  {
    "paragraph": "What you want to avoid are stories that are only valued by developers. For example, avoid stories like these:"
  },
  {
    "paragraph": "All connections to the database are through a connection pool."
  },
  {
    "paragraph": "All error handling and logging is done through a set of common classes."
  },
  {
    "paragraph": "Accept the fact that you simply can’t learn everything. Remember, desires are endless; needs are limited. Accept the fact that newer is not always better. There are people working with ancient programming languages and still making a lot of money. Practice daily the subtle art of saying ‘no’. No to that newest library. No to that fancier platform. Say more ‘noes’ so you can say ‘yes’ to what really matters to you."
  },
  {
    "paragraph": "what problem is this new technology or framework trying to solve?"
  },
  {
    "paragraph": "If you decide to become a great developer, it’s important to understand core concepts such as algorithms, logic, network, accessibility, security, and user experience. You don’t necessarily need them to build your first app, but knowing them will help you build the next ten complex applications you will create in the future."
  },
  {
    "paragraph": "“If you really want to learn something, you have to teach it”."
  },
  {
    "paragraph": "One way of truly knowing a concept or technology is trying to create a practical project. Another very effective method is when you try to explain it to someone else"
  },
  {
    "paragraph": "“Everything that needs to be said has already been said. But, since no one was listening, everything must be said again.” ― Austin Kleon"
  },
  {
    "paragraph": "you can’t win in programming, you can only keep evolving the software to be better, more scalable, and more useful every day."
  },
  {
    "paragraph": "Don’t try to be clever, don’t try to code something to make you feel smarter, you don’t need to show off all the new tricks you just learned. Just write readable code. Think about maintainability, and use meaningful names for your classes, functions, and variables. Next time you start developing, ask yourself this question: “Will the future me understand the intention of this code?”"
  },
  {
    "paragraph": "However, I truly believe that if you want to have a successful career in tech, you need to invest extra hours into your craft."
  },
  {
    "paragraph": "The better you understand the business, the more capable you will be to solve those problems yourself."
  },
  {
    "paragraph": "Every industry is different, so there’s no recipe to follow when it comes to better knowing the business side. However, my recommendation is to start with the vocabulary. Pay attention to the specific words and terms used by the business folks. If you emulate the same terminology, the communication with them will be much more effective. Once you start reading and consuming more content about your industry, you will naturally develop more domain knowledge."
  },
  {
    "paragraph": "One misconception many people have is that we need to listen to reply, whereas in reality, we need to listen to understand. Understanding someone is far more important than replying to someone. Anyone can reply, few can understand."
  },
  {
    "paragraph": "The greatest of all weaknesses is the fear of appearing weak."
  },
  {
    "paragraph": "Provide Options, Don't Make Lame Excuses."
  },
  {
    "paragraph": "Don't leave \"broken windows\" (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered. If there is insufficient time to fix it properly, then board it up. Perhaps you can comment out the offending code, or display a \"Not Implemented\" message, or substitute dummy data instead. Take some action to prevent further damage and to show that you're on top of the situation."
  },
  {
    "paragraph": "Broken Window Theory, people lose the will to fight entropy because they perceive that no one else cares. The frog just doesn't notice the change."
  },
  {
    "paragraph": "Striving to better, oft we mar what's well. (Daha iyisi için çabalarken çoğu zaman iyi olanıda bozarız.)"
  },
  {
    "paragraph": "If you give your users something to play with early, their feedback will often lead you to a better eventual solution"
  },
  {
    "paragraph": "An investment in knowledge always pays the best interest."
  },
  {
    "paragraph": "This is a very dynamic industry. That hot technology you started investigating last month might be stone cold by now. Maybe you need to brush up on that database technology that you haven't used in a while. Or perhaps you could be better positioned for that new job opening if you tried out that other language...."
  },
  {
    "paragraph": "Learn at least one new language every year. Different languages solve the same problems in different ways. By learning several different approaches, you can help broaden your thinking and avoid getting stuck in a rut."
  },
  {
    "paragraph": "Once you're in the habit, read a book a month."
  },
  {
    "paragraph": "It is important to remember that computers are used by people—people whose needs you are trying to satisfy. Don't forget the human side of the equation."
  },
  {
    "paragraph": "Look for interesting courses at your local community college or university, or perhaps at the next trade show that comes to town."
  },
  {
    "paragraph": "Don't just go and listen, but actively participate. Isolation can be deadly to your career; find out what people are working on outside of your company."
  },
  {
    "paragraph": "If you've worked only in Windows, play with Unix at home (the freely available Linux is perfect for this). If you've used only makefiles and an editor, try an IDE, and vice versa."
  },
  {
    "paragraph": "Stay current. Subscribe to trade magazines and other journals (see page 262 for recommendations). Choose some that cover technology different from that of your current project."
  },
  {
    "paragraph": "Sit back and be patient. People are busy, and it may take days to get a specific answer."
  },
  {
    "paragraph": "Having the best ideas, the finest code, or the most pragmatic thinking is ultimately sterile unless you can communicate with other people."
  },
  {
    "paragraph": "There's one technique that you must use if you want people to listen to you: listen to them."
  },
  {
    "paragraph": "Encourage people to talk by asking questions, or have them summarize what you tell them. Turn the meeting into a dialog, and you'll make your point more effectively. Who knows, you might even learn something."
  },
  {
    "paragraph": "Always respond to e-mails and voice mails, even if the response is simply \"I'll get back to you later.\" Keeping people informed makes them far more forgiving of the occasional slip, and makes them feel that you haven't forgotten them."
  },
  {
    "paragraph": "Unless you work in a vacuum, you need to be able to communicate. The more effective that communication, the more influential you become."
  },
  {
    "paragraph": "Most people assume that maintenance begins when an application is released, that maintenance means fixing bugs and enhancing features. We think these people are wrong. Programmers are constantly in maintenance mode. Our understanding changes day by day. New requirements arrive as we're designing or coding. Perhaps the environment changes. Whatever the reason, maintenance is not a discrete activity, but a routine part of the entire development process."
  },
  {
    "paragraph": "With a bit of ingenuity you can normally remove the need for duplication. Often the answer is to write a simple filter or code generator."
  },
  {
    "paragraph": "Sometimes, duplication comes about as the result of mistakes in the design."
  },
  {
    "paragraph": "Where possible, always use accessor functions to read and write the attributes of objects.[1] It will make it easier to add functionality, such as caching, in the future."
  },
  {
    "paragraph": "Impatient duplication is an easy form to detect and handle, but it takes discipline and a willingness to spend time up front to save pain later."
  },
  {
    "paragraph": "if it isn't easy, people won't do it. And if you fail to reuse, you risk duplicating knowledge."
  },
  {
    "paragraph": "We want to design components that are self-contained: independent, and with a single, well-defined purpose. When components are isolated from one another, you know that you can change one without having to worry about the rest. As long as you don't change that component's external interfaces, you can be comfortable that you won't cause problems that ripple through the entire system."
  },
  {
    "paragraph": "The more loosely coupled your systems, the easier they are to reconfigure and reengineer."
  },
  {
    "paragraph": "An orthogonal approach reduces the risks inherent in any development. Diseased sections of code are isolated. If a module is sick, it is less likely to spread the symptoms around the rest of the system. It is also easier to slice it out and transplant in something new and healthy."
  },
  {
    "paragraph": "When teams are organized with lots of overlap, members are confused about responsibilities. Every change needs a meeting of the entire team, because any one of them might be affected."
  },
  {
    "paragraph": "Also ask yourself how decoupled your design is from changes in the real world. Are you using a telephone number as a customer identifier? What happens when the phone company reassigns area codes? Don't rely on the properties of things you can't control."
  },
  {
    "paragraph": "Keep your code decoupled. Write shy code—modules that don't reveal anything unnecessary to other modules and that don't rely on other modules' implementations."
  },
  {
    "paragraph": "Get into the habit of being constantly critical of your code. Look for any opportunities to reorganize it to improve its structure and orthogonality. This process is called refactoring,"
  },
  {
    "paragraph": "Nothing is more dangerous than an idea if it's the only one you have."
  },
  {
    "paragraph": "Prototyping is a learning experience. Its value lies not in the code produced, but in the lessons learned. That's really the point of prototyping."
  },
  {
    "paragraph": "Computer languages influence how you think about a problem, and how you think about communicating. Every language comes with a list of features—buzzwords such as static versus dynamic typing, early versus late binding, inheritance models (single, multiple, or none)—all of which may suggest or obscure certain solutions. Designing a solution with Lisp in mind will produce different results than a solution based on C-style thinking, and vice versa. Conversely, and we think more importantly, the language of the problem domain may also suggest a programming solution."
  },
  {
    "paragraph": "Tools amplify your talent. The better your tools, and the better you know how to use them, the more productive you can be."
  },
  {
    "paragraph": "you can't be a great programmer until you become highly skilled at Debugging."
  },
  {
    "paragraph": "All software becomes legacy as soon as it's written."
  },
  {
    "paragraph": "Use the Power of Command Shells"
  },
  {
    "paragraph": "Always Use Source Code Control"
  },
  {
    "paragraph": "Fix the Problem, Not the Blame"
  },
  {
    "paragraph": "It doesn't really matter whether the bug is your fault or someone else's. It is still your problem."
  },
  {
    "paragraph": "The easiest person to deceive is one's self"
  },
  {
    "paragraph": "Always try to discover the root cause of a problem, not just this particular appearance of it."
  },
  {
    "paragraph": "You may need to interview the user who reported the bug in order to gather more data than you were initially given."
  },
  {
    "paragraph": "Artificial tests (such as the programmer's single brush stroke from bottom to top) don't exercise enough of an application. You must brutally test both boundary conditions and realistic end-user usage patterns. You need to do this systematically (see Ruthless Testing)."
  },
  {
    "paragraph": "A very simple but particularly useful technique for finding the cause of a problem is simply to explain it to someone else"
  },
  {
    "paragraph": "It is possible that a bug exists in the OS, the compiler, or a third-party product—but this should not be your first thought."
  },
  {
    "paragraph": "Don't Assume It—Prove It"
  },
  {
    "paragraph": "Finally, if the bug is the result of someone's wrong assumption, discuss the problem with the whole team: if one person misunderstands, then it's possible many people do."
  },
  {
    "paragraph": "Unix developers often like to use the power of their command shells, augmented with tools such as awk and sed. Learn a Text Manipulation Language"
  },
  {
    "paragraph": "Write Code That Writes Code"
  },
  {
    "paragraph": "Keep the input format simple, and the code generator becomes simple."
  },
  {
    "paragraph": "You can use code generators to write just about any output: HTML, XML, plain text—any text that might be an input somewhere else in your project."
  },
  {
    "paragraph": "You Can't Write Perfect Software"
  },
  {
    "paragraph": "Java keyword final to indicate our intentions that the parameter shouldn't be changed within the method."
  },
  {
    "paragraph": "you can get much greater benefit by having the compiler check your contract for you"
  },
  {
    "paragraph": "when your code discovers that something that was supposed to be impossible just happened, your program is no longer viable. Anything it does from this point forward becomes suspect, so terminate it as soon as possible. A dead program normally does a lot less damage than a crippled one."
  },
  {
    "paragraph": "If It Can't Happen, Use Assertions to Ensure That It Won't"
  },
  {
    "paragraph": "we suggested that it is good practice to check for every possible error—particularly the unexpected ones"
  },
  {
    "paragraph": "However, many developers have no consistent plan for dealing with resource allocation and deallocation. So let us suggest a simple tip: Tip 35 Finish What You Start"
  },
  {
    "paragraph": "The class represents a resource, the constructor gives you a particular object of that resource type, and the destructor removes it from your scope."
  },
  {
    "paragraph": "Because Pragmatic Programmers trust no one, including ourselves, we feel that it is always a good idea to build code that actually checks that resources are indeed freed appropriately."
  },
  {
    "paragraph": "A good way to stay flexible is to write less code. Changing code leaves you open to the possibility of introducing new bugs."
  },
  {
    "paragraph": "we suggested that writing \"shy\" code is beneficial. But \"shy\" works two ways: don't reveal yourself to others, and don't interact with too many people."
  },
  {
    "paragraph": "If n objects all know about each other, then a change to just one object can result in the other n 1 objects needing changes."
  },
  {
    "paragraph": "Configure, Don't Integrate"
  },
  {
    "paragraph": "program for the general case, and put the specifics somewhere else—outside the compiled code base."
  },
  {
    "paragraph": "we recommend representing configuration metadata in plain text—it makes life that much easier."
  },
  {
    "paragraph": "Without metadata, your code is not as adaptable or flexible as it could be. Is this a bad thing? Well, out here in the real world, species that don't adapt die."
  },
  {
    "paragraph": "Don't let your project (or your career) go the way of the dodo."
  },
  {
    "paragraph": "We need to allow for concurrency and to think about decoupling any time or order dependencies. In doing so, we can gain flexibility and reduce any time-based dependencies in many areas of development: workflow analysis, architecture, design, and deployment."
  },
  {
    "paragraph": "Always Design for Concurrency"
  },
  {
    "paragraph": "If we design to allow for concurrency, we can more easily meet scalability or performance requirements when the time comes"
  },
  {
    "paragraph": "Objects should be able to register to receive only the events they need, and should never be sent events they don't need. We don't want to spam our objects"
  },
  {
    "paragraph": "Something that should be in the back of your mind whenever you're producing code is that you'll someday have to test it. Make code easy to test, and you'll increase the likelihood that it will actually get tested,"
  },
  {
    "paragraph": "Fred doesn't know why the code is failing because he didn't know why it worked in the first place."
  },
  {
    "paragraph": "It may not really be working—it might just look like it is. The boundary condition you rely on may be just an accident. In different circumstances (a different screen resolution, perhaps), it might behave differently. Undocumented behavior may change with the next release of the library. Additional and unnecessary calls make your code slower. Additional calls also increase the risk of introducing new bugs of their own."
  },
  {
    "paragraph": "Always be aware of what you are doing. Fred let things get slowly out of hand, until he ended up boiled, like the frog in Stone Soup and Boiled Frogs."
  },
  {
    "paragraph": "So next time something seems to work, but you don't know why, make sure it isn't just a coincidence."
  },
  {
    "paragraph": "estimating the resources that algorithms use—time, processor, memory, and so on."
  },
  {
    "paragraph": "Estimate the Order of Your Algorithms"
  },
  {
    "paragraph": "You also need to be pragmatic about choosing appropriate algorithms—the fastest one is not always the best for the job. Given a small input set, a straightforward insertion sort will perform just as well as a quicksort, and will take you less time to write and debug."
  },
  {
    "paragraph": "As a program evolves, it will become necessary to rethink earlier decisions and rework portions of the code. This process is perfectly natural. Code needs to evolve; it's not a static thing."
  },
  {
    "paragraph": "When you come across a stumbling block because the code doesn't quite fit anymore, or you notice two things that should really be merged, or anything else at all strikes you as being \"wrong,\" don't hesitate to change it"
  },
  {
    "paragraph": "Keep track of the things that need to be refactored. If you can't refactor something immediately, make sure that it gets placed on the schedule. Make sure that users of the affected code know that it is scheduled to be refactored and how this might affect them."
  },
  {
    "paragraph": "Take short, deliberate steps: move a field from one class to another, fuse two similar methods into a superclass. Refactoring often involves making many localized changes that result in a larger-scale change. If you keep your steps small, and test after each step, you will avoid prolonged debugging."
  },
  {
    "paragraph": "if the code broke once, it is likely to break again. Don't just throw away the test you created; add it to the existing unit test."
  },
  {
    "paragraph": "All software you write will be tested—if not by you and your team, then by the eventual users—so you might as well plan on testing it thoroughly: Test Your Software, or Your Users Will"
  },
  {
    "paragraph": "But unless Joe actually understands the code that has been produced on his behalf, he's fooling himself. He's programming by coincidence."
  },
  {
    "paragraph": "Perfection is achieved, not when there is nothing left to add, but when there is nothing left to take away...."
  },
  {
    "paragraph": "Documenting the reasons behind requirements will give your team invaluable information when making daily implementation decisions."
  },
  {
    "paragraph": "Requirements are not architecture. Requirements are not design, nor are they the user interface. Requirements are need."
  },
  {
    "paragraph": "Abstractions Live Longer than Details"
  },
  {
    "paragraph": "Create and maintain a project glossary—one place that defines all the specific terms and vocabulary used in a project. All participants in the project, from end users to support staff, should use the glossary to ensure consistency."
  },
  {
    "paragraph": "Sometimes you will find yourself working on a problem that seems much harder than you thought it should be. Maybe it feels like you're going down the wrong path—that there must be an easier way than this!"
  },
  {
    "paragraph": "As a developer, you've been doing the same kind of thing during your entire career. You've been trying things and seeing which worked and which didn't. You've been accumulating experience and wisdom. When you feel a nagging doubt, or experience some reluctance when faced with a task, heed it. You may not be able to put your finger on exactly what's wrong, but give it time and your doubts will probably crystallize into something more solid, something you can address. Software development is still not a science. Let your instincts contribute to your performance."
  },
  {
    "paragraph": "Good developers tend to be passionate about their work."
  },
  {
    "paragraph": "A great way to ensure both consistency and accuracy is to automate everything the team does"
  },
  {
    "paragraph": "Civilization advances by extending the number of important operations we can perform without thinking."
  },
  {
    "paragraph": "When you don't run tests regularly, you may discover that the application broke due to a code change made three months ago. Good luck finding that one."
  },
  {
    "paragraph": "Misleading information is worse than no information at all."
  },
  {
    "paragraph": "Most developers hate testing. They tend to test gently, subconsciously knowing where the code will break and avoiding the weak spots. Pragmatic Programmers are different. We are driven to find our bugs now, so we don't have to endure the shame of others finding our bugs later."
  },
  {
    "paragraph": "Coding Ain't Done 'Til All the Tests Run"
  },
  {
    "paragraph": "If the parts don't work by themselves, they probably won't work well together. All of the modules you are using must pass their own unit tests before you can proceed."
  },
  {
    "paragraph": "Usability testing is different from the types of testing discussed so far. It is performed with real users, under real environmental conditions."
  },
  {
    "paragraph": "(Not only do we want our own tools to fit our hands, but we want the tools we create for users to fit their hands as well.)"
  },
  {
    "paragraph": "Because we can't write perfect software, it follows that we can't write perfect test software either. We need to test the tests."
  },
  {
    "paragraph": "Test State Coverage, Not Code Coverage"
  },
  {
    "paragraph": "Once a human tester finds a bug, it should be the last time a human tester finds that bug."
  },
  {
    "paragraph": "The palest ink is better than the best memory."
  },
  {
    "paragraph": "In general, comments should discuss why something is done, its purpose and its goal. The code already shows how it is done, so commenting on this is redundant—and is a violation of the DRY principle."
  },
  {
    "paragraph": "a document's presentation should be independent of its content."
  },
  {
    "paragraph": "Documentation and code are different views of the same underlying model, but the view is all that should be different. Don't let documentation become a second-class citizen, banished from the main project workflow. Treat documentation with the same care you treat code, and the users (and maintainers who follow) will sing your praises."
  },
  {
    "paragraph": "In reality, the success of a project is measured by how well it meets the expectations of its users. A project that falls below their expectations is deemed a failure, no matter how good the deliverable is in absolute terms."
  },
  {
    "paragraph": "Pragmatic Programmers don't shirk from responsibility. Instead, we rejoice in accepting challenges and in making our expertise well known. If we are responsible for a design, or a piece of code, we do a job we can be proud of. Tip: Sign Your Work"
  },
  {
    "paragraph": "$ git checkout -b \u003cbranch ismi\u003e"
  },
  {
    "paragraph": "Yeni bir branch açıp, ona geçiyor."
  },
  {
    "paragraph": "$ git stash list"
  },
  {
    "paragraph": "$ git stash pop"
  },
  {
    "paragraph": "En son değişikliğin Stash’den silinerek dala geri yüklenmesi"
  },
  {
    "paragraph": "$ git stash apply stash@{0}"
  },
  {
    "paragraph": "En son değişikliğin Stash’den silinmeden dala geri yüklenmesi"
  },
  {
    "paragraph": "$ git stash drop stash@{2}"
  },
  {
    "paragraph": "Stashdeki bir değişikliğin yüklenmeden silinmesi"
  },
  {
    "paragraph": "Birleştirme için dal\u003emerge\u003emaster şeklinde bir işlem sırası var ve bunun komutu da merge. Hangi dala (hedef dal) entegre edecekseniz öncelikle git checkout komutu ile o dalı aktif hale getirmelisiniz. Daha sonra da hedef dalda iken git merge \u003ckaynak_dal_adı\u003e komutu ile birleştirme yapabiliriz."
  },
  {
    "paragraph": "Rebase işlemi uzaktaki ana dalınız ile yerenel ana dalınızın birleştirilmesi işlemidir."
  },
  {
    "paragraph": "$ git pull --rebase origin master"
  },
  {
    "paragraph": "Son COMMIT Açıklamasını Düzeltmek"
  },
  {
    "paragraph": "# Son commit işlemini tekrarlamak için"
  },
  {
    "paragraph": "git commit --amend"
  },
  {
    "paragraph": "# Son commit işlemini içeriğini değiştirmeden sadece mesajını düzeltmek için"
  },
  {
    "paragraph": "git commit --amend -m"
  },
  {
    "paragraph": "# Son commit işlemini içeriğini düzeltmek değişikliklerinizi yaptıktan sonrası sırası ile"
  },
  {
    "paragraph": "git add -A ."
  },
  {
    "paragraph": "git commit --amend"
  },
  {
    "paragraph": "# git reset --hard"
  },
  {
    "paragraph": "Tüm dosyalardaki değişikliği tek kodla geri almak için"
  },
  {
    "paragraph": "Commit edilen bir değişikliği geri almak"
  },
  {
    "paragraph": "git revert \u003crevert ettiğiniz commitin hash değeri\u003e"
  },
  {
    "paragraph": "The first thing you need to know is that Puppeteer was not created to compete with Selenium. Selenium is a cross-language, cross-browser testing tool, whereas Puppeteer was created as a multi-purpose automation tool to exploit all the power of Chromium."
  },
  {
    "paragraph": "A headless browser is a browser that you can launch and interact with using a particular protocol over a particular communication transport, with no UI involved"
  },
  {
    "paragraph": "Puppeteer is nothing more, and nothing less, than a Node.js package that knows how to open a browser, send commands, and react to messages coming from that browser."
  },
  {
    "paragraph": "A browser can contain more than one context. A context is a browser session (not to be confused with a browser window). The best example is the Incognito Mode or private mode, depending on the browser, which creates an isolated session inside the same browser process."
  },
  {
    "paragraph": "A page is a tab in a browser or even a pop-up page."
  },
  {
    "paragraph": "The frame object is more important than it looks. Every page has at least one frame, which is called the main frame. ex. page.click calls mainframe.click."
  },
  {
    "paragraph": "The execution context is a mechanism Chromium uses to isolate the page from the browser extensions. Each frame will have its own execution context. Internally, all the frame functions that involve executing JavaScript code will use an execution context to run the code inside the browser."
  },
  {
    "paragraph": "Service tests are also known as Integration Tests. These tests will check how your code interacts with other components. When we talk about components, we are talking about the following:"
  },
  {
    "paragraph": "• Databases"
  },
  {
    "paragraph": "• Other components in the app"
  },
  {
    "paragraph": "• External services"
  },
  {
    "paragraph": "Puppeteer.launch func params"
  },
  {
    "paragraph": "ignoreHTTPSErrors: Whether to ignore HTTPS errors during navigation. This option will become handy when you want to automate websites with invalid or missing SSL certificates."
  },
  {
    "paragraph": "slowMo: Slows down Puppeteer operations by the specified number of milliseconds."
  },
  {
    "paragraph": "a viewport is the visible portion of the entire document."
  },
  {
    "paragraph": "networkidle0 will resolve the promise when there are no more network connections for the past 500ms. On the other hand, networkidle2 will resolve the promise when there are no more than 2 network connections for the past 500ms."
  },
  {
    "paragraph": "HTML5 brought a new kind of container element: The Semantic Elements. The goal of these semantic HTML elements is to communicate the type of content the element contains. So, instead of using DIVs for everything, developers should start using elements such as \u003cheader\u003e for the site header, \u003cfooter\u003e for the footer, \u003cnav\u003e for the navigation options, \u003carticles\u003e for blog posts, and so on. The purpose of these elements is to help external tools (such as screen readers, search engines, and even the same browser) to understand the HTML content."
  },
  {
    "paragraph": "Puppeteer provides two functions to get elements from the page. The $(selector) function will run the document.querySelector function and return the first element matching that selector or null if no elements were found. The $$(selector) function will run the document.querySelectorAll function, returning an array of elements matching the selector or an empty array if no elements were found."
  },
  {
    "paragraph": "$x('//div/a'), which would mean \"Bring me all the div elements, and from there all the a elements that are a direct child of those divs."
  },
  {
    "paragraph": "Selector: [@attributeName=value]."
  },
  {
    "paragraph": "$x('//div[@class=\"card-body\"]')"
  },
  {
    "paragraph": "Selector: [text()=value]."
  },
  {
    "paragraph": "Selector:[contains(text(), value)]."
  },
  {
    "paragraph": "Promise.all will wait for all promises to finish. It will also resolve as soon as one promise fails."
  },
  {
    "paragraph": "Whatever you undertake, act with prudence and consider the consequences."
  },
  {
    "paragraph": "Technical debt is like a loan: you benefit from it in the short term, but you have to pay interest on it until it is fully paid off. Pay off technical debt as soon as possible. It would be imprudent to do otherwise."
  },
  {
    "paragraph": "WE ALL TEND TO ASSUME THAT OTHER PEOPLE THiNK LiKE US. But they don’t."
  },
  {
    "paragraph": "The best way to find out how a user thinks is to watch one. Ask a user to complete a task using a similar piece of software to what you’re developing. Make sure the task is a real one: “Add up a column of numbers” is OK; “Calculate your expenses for the last month” is better."
  },
  {
    "paragraph": "It’s why the best way to capture requirements is to watch users. Spending an hour watching users is more informative than spending a day guessing what they want. It’s why the best way to capture requirements is to watch users. Spending an hour watching users is more informative than spending a day guessing what they want."
  },
  {
    "paragraph": "Make sure code formatting is part of the build process, so that everybody runs it automatically every time they compile the code."
  },
  {
    "paragraph": "Use static code analysis tools to scan the code for unwanted antipatterns. If any are found, break the build."
  },
  {
    "paragraph": "Learn to configure those tools so that you can scan for your own, projectspecific antipatterns."
  },
  {
    "paragraph": "Do not only measure test coverage, but automatically check the results, too. Again, break the build if test coverage is too low."
  },
  {
    "paragraph": "Beauty of style and harmony and grace and good rhythm depends on simplicity."
  },
  {
    "paragraph": "If you haven’t spent time studying other people’s code, stop reading this right now and find some open source code to study. Seriously!"
  },
  {
    "paragraph": "Avoid the temptation to rewrite everything. It is best to reuse as much code as possible. No matter how ugly the code is, it has already been tested, reviewed, etc."
  },
  {
    "paragraph": "Many incremental changes are better than one massive change."
  },
  {
    "paragraph": "After each development iteration, it is important to ensure that the existing tests pass."
  },
  {
    "paragraph": "Personal preferences and ego shouldn’t get in the way. If something isn’t broken, why fix it?"
  },
  {
    "paragraph": "New technology is an insufficient reason to refactor."
  },
  {
    "paragraph": "Remember that humans make mistakes. Restructuring will not always guarantee that the new code will be better—or even as good as—the previous attempt."
  },
  {
    "paragraph": "“Always leave the campground cleaner than you found it.” If you find a mess on the ground, you clean it up regardless of who might have made it."
  },
  {
    "paragraph": "You don’t have to make every module perfect before you check it in. You simply have to make it a little bit better than when you checked it out."
  },
  {
    "paragraph": "You might simply improve the name of one variable, or split one long function into two smaller functions. You might break a circular dependency, or add an interface to decouple policy from detail."
  },
  {
    "paragraph": "the act of leaving a mess in the code should be as socially unacceptable as littering. It should be something that just isn’t done."
  },
  {
    "paragraph": "Given how rare compiler bugs are, you are far better putting your time and energy into finding the error in your code than into proving that the compiler is wrong. All the usual debugging advice applies, so isolate the problem, stub out calls, and surround it with tests; check calling conventions, shared libraries, and version numbers; explain it to someone else; look out for stack corruption and variable type mismatches; and try the code on different machines and different build configurations, such as debug and release."
  },
  {
    "paragraph": "My personal strategy to mitigate these problems is to start small by using only the tools that are absolutely necessary."
  },
  {
    "paragraph": "I also tend to isolate the external tools from my business domain objects by means of interfaces and layering, so that I can change the tool if I have to with a minimal amount of pain."
  },
  {
    "paragraph": "Making domain concepts explicit in your code means other programmers can gather the intent of the code much more easily than by trying to retrofit an algorithm into what they understand about a domain."
  },
  {
    "paragraph": "Make your functions short and focused on a single task. The old 24-line limit still applies."
  },
  {
    "paragraph": "Functions should have few parameters (four is a good upper bound)."
  },
  {
    "paragraph": "“If it was hard to write, it should be hard to read,”"
  },
  {
    "paragraph": "What of comments that are not technically wrong, but add no value to the code? Such comments are noise"
  },
  {
    "paragraph": "Each comment should add some value for the reader, otherwise it is waste that should be removed or rewritten."
  },
  {
    "paragraph": "Comments should say something code does not and cannot say."
  },
  {
    "paragraph": "Try to express as much as possible through code."
  },
  {
    "paragraph": "Comment what the code cannot say, not simply what it does not say."
  },
  {
    "paragraph": "you need to take responsibility for your own education."
  },
  {
    "paragraph": "Read books, magazines, blogs, Twitter feeds, and websites. If you want to go deeper into a subject, consider joining a mailing list or newsgroup."
  },
  {
    "paragraph": "If you really want to get immersed in a technology, get hands on—write some code."
  },
  {
    "paragraph": "Always try to work with a mentor, as being the top guy can hinder your education. Although you can learn something from anybody, you can learn a whole lot more from someone smarter or more experienced than you. If you can’t find a mentor, consider moving on."
  },
  {
    "paragraph": "Use virtual mentors. Find authors and developers on the Web who you really like and read everything they write. Subscribe to their blogs."
  },
  {
    "paragraph": "Get to know the frameworks and libraries you use. Knowing how something works makes you know how to use it better. If they’re open source, you’re really in luck. Use the debugger to step through the code to see what’s going on under the hood. You’ll get to see code written and reviewed by some really smart people."
  },
  {
    "paragraph": "Whenever you make a mistake, fix a bug, or run into a problem, try to really understand what happened. It’s likely that someone else ran into the same problem and posted it on the Web. Google is really useful here."
  },
  {
    "paragraph": "A good way to learn something is to teach or speak about it. When people are going to listen to you and ask you questions, you’ll be highly motivated to learn. Try a lunch-’n’-learn at work, a user group, or a local conference."
  },
  {
    "paragraph": "Join or start a study group (à la patterns community) or a local user group for a language, technology, or discipline you are interested in."
  },
  {
    "paragraph": "Go to conferences. And if you can’t go, many conferences put their talks online for free."
  },
  {
    "paragraph": "Long commute? Listen to podcasts."
  },
  {
    "paragraph": "Follow the advice of the Pragmatic Programmers* and learn a new language every year. At least learn a new technology or tool. Branching out gives you new ideas you can use in your current technology stack."
  },
  {
    "paragraph": "Not everything you learn has to be about technology. Learn the domain you’re working in so you can better understand the requirements and help solve the business problem. Learning how to be more productive— how to work better—is another good option."
  },
  {
    "paragraph": "APIs are supposed to hide underlying complexity, so we can realistically expect good API design to require some effort."
  },
  {
    "paragraph": "An API should provide an expressive language, which gives the next layer above sufficient vocabulary to ask and answer useful questions."
  },
  {
    "paragraph": "For example, we prefer to say run instead of walk(true), even though it could be viewed as essentially the same operation, just executed at different speeds."
  },
  {
    "paragraph": "Starting your project with an installation process will give you time to evolve the process as you move through the product development cycle, and the chance to make changes to the application code to make the installation easier."
  },
  {
    "paragraph": "Putting deployment last means that the deployment process may need to be more complicated to work around assumptions in the code."
  },
  {
    "paragraph": "THERE ARE BASiCALLY TWO REASONS that things go wrong at runtime: technical problems that prevent us from using the application and business logic that prevents us from misusing the application"
  },
  {
    "paragraph": "Mixing technical exceptions and business exceptions in the same hierarchy blurs the distinction and confuses the caller about what the method contract is, what conditions it is required to ensure before calling, and what situations it is supposed to handle. Separating the cases gives clarity and increases the chances that technical exceptions will be handled by some application framework, while the business domain exceptions actually are considered and handled by the client code."
  },
  {
    "paragraph": "Deliberate practice means practicing something you are not good at. The key [to developing expertise] is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Deliberate practice does not mean doing what you are good at; it means challenging yourself, doing what you are not good at. So it’s not necessarily fun.Deliberate practice is about learning—learning that changes you, learning that changes your behavior."
  },
  {
    "paragraph": "Be the surgeon who isn’t afraid to cut out the sick parts to make room for healing. The attitude is contagious and will inspire others to start working on those cleanup projects they’ve been putting off. Keep a “hygiene” list of tasks that the team feels are worthwhile for the general good of the project."
  },
  {
    "paragraph": "“a lie can travel halfway around the world while the truth is putting on its shoes,”"
  },
  {
    "paragraph": "In summary, when writing any text in your code—whether comments, logging, dialogs, or test data—always ask yourself how it will look if it becomes public."
  },
  {
    "paragraph": "No matter how unlikely you think an error is in your code, you should always check for it, and always handle it. Every time. You’re not saving time if you don’t; you’re storing up potential problems for the future."
  },
  {
    "paragraph": "If you ignore an error, turn a blind eye, and pretend that nothing has gone wrong, you run great risks."
  },
  {
    "paragraph": "Deal with problems at the earliest opportunity."
  },
  {
    "paragraph": "Don’t Just Learn the Language, Understand Its Culture"
  },
  {
    "paragraph": "it takes more than just learning the syntax to learn a language: you need to understand its culture."
  },
  {
    "paragraph": "If you instead explore new languages to expand your mind and get fresh ideas on how you can solve things in different ways, you will find that the code you write in your trusty old language gets more beautiful for every new language you’ve learned."
  },
  {
    "paragraph": "“every piece of knowledge must have a single, unambiguous, authoritative representation within a system.”"
  },
  {
    "paragraph": "The goal is to ensure that there is only one way of accomplishing the task, and it is as painless as possible."
  },
  {
    "paragraph": "Floating-point numbers are intended for efficient scientific computation. But efficiency is worthless without accuracy, so remember the source of rounding errors, and code accordingly!"
  },
  {
    "paragraph": "The harder you work on an open source project, the faster you’ll realize your true ambitions as a programmer."
  },
  {
    "paragraph": "you could start by volunteering to write test code. While that may not sound exciting, the truth is you learn much faster by writing test code for other people’s software than almost any other activity in software."
  },
  {
    "paragraph": "It’s not enough to write tests for an API you develop; you have to write unit tests for code that uses your API."
  },
  {
    "paragraph": "If someone seems like a guru, it’s because of years dedicated to learning and refining thought processes. A “guru” is simply a smart person with relentless curiosity."
  },
  {
    "paragraph": "by working less, you might achieve more"
  },
  {
    "paragraph": "You need to spend evenings, weekends, and holidays educating yourself; therefore, you cannot spend your evenings, weekends, and holidays working overtime on your current project."
  },
  {
    "paragraph": "Don’t blame others or deny the bug’s very existence. Instead, ask for more information or consider what you could have missed."
  },
  {
    "paragraph": "Improve Code by Removing It"
  },
  {
    "paragraph": "(Hint: Write code because it adds value, not because it amuses you.)"
  },
  {
    "paragraph": "Someone thought that it might be needed in the future, so felt it was best to code it now. (Hint: That isn’t YAGNI. If you don’t need it right now, don’t write it right now.)"
  },
  {
    "paragraph": "When you’re designing an application, be mindful of the number of interprocess communications in response to each stimulus. When analyzing applications that suffer from poor performance, I have often found IPC-to-stimulus ratios of thousands-to-one. Reducing this ratio, whether by caching or parallelizing or some other technique, will pay off much more than changing data structure choice or tweaking a sorting algorithm."
  },
  {
    "paragraph": "To make warnings useful again, I try to use a zero-tolerance policy for warnings from the build. Even if the warning isn’t important, I deal with it. If it’s not critical but still relevant, I fix it. If the compiler warns about a potential null-pointer exception, I fix the cause—even if I “know” the problem will never show up in production. If the embedded documentation (Javadoc or similar) refers to parameters that have been removed or renamed, I clean up the documentation."
  },
  {
    "paragraph": "By making sure that the build is always clean, I will not have to decide that a warning is irrelevant every time I encounter it. Ignoring things is mental work, and I need to get rid of all the unnecessary mental work I can."
  },
  {
    "paragraph": "Don’t wait for a big cleanup. When something appears that you don’t want to see, deal with it right away."
  },
  {
    "paragraph": "when a tool is easy to use, it’s because the tool is making decisions for you and doing a lot of things automatically, behind the scenes."
  },
  {
    "paragraph": "By working with command-line build tools, you will learn a lot more about what the tools are doing when your project is being built."
  },
  {
    "paragraph": "Programmers should always be interested in learning new languages, preferably from an unfamiliar paradigm."
  },
  {
    "paragraph": "My first step in learning an IDE is to memorize the keyboard shortcuts."
  },
  {
    "paragraph": "PROGRAMMERS NEED TO COMMUNiCATE. A lot."
  },
  {
    "paragraph": "Good programmers need to be able to stand outside their daily routine, to be aware of other languages that are expressive for other purposes. The time always comes when this pays off."
  },
  {
    "paragraph": "Most of the best programmers I know are also very fluent in their mother tongue, and typically in other languages as well."
  },
  {
    "paragraph": "A linker is a stupid, pedestrian, straightforward program. All it does is concatenate together the code and data sections of the object files, connect the references to symbols with their definitions, pull unresolved symbols out of the library, and write out an executable"
  },
  {
    "paragraph": "polymorphism refers to many forms of a particular class of objects or method."
  },
  {
    "paragraph": "Automating configuration in the build can enable you to get consistent results when multiple people are working on a project, avoiding an “it works for me” conversation. Many build tools allow you to run reports on code quality, allowing you to sense potential problems early. By spending time understanding how to make the build yours, you can help yourself and everyone else on your team. You can focus on coding features, benefiting your stakeholders and making work more enjoyable."
  },
  {
    "paragraph": "As a team member, be patient with developers less experienced than you. Confront your fears about being intimidated by more skilled developers. Realize that people are different, and value it. Be aware of your own strengths and weaknesses, as well as those of other team members. You may be surprised by how much you can learn from your colleagues."
  },
  {
    "paragraph": "The code becomes more readable, as it expresses concepts of a domain, not just Float or String. • The code becomes more testable, as the code encapsulates behavior that is easily testable. • The code facilitates reuse across applications and systems."
  },
  {
    "paragraph": "The moral is to start exploring domain-specific types for the purpose of developing quality software."
  },
  {
    "paragraph": "YOU’VE BEEN FOCUSED FOR HOURS on some gnarly problem, and there’s no solution in sight. So you get up to stretch your legs or to hit the vending machines and, on the way back, the answer suddenly becomes obvious."
  },
  {
    "paragraph": "So, the next time you hit a nasty problem, do yourself a favor. Once you really understand the problem, go do something involving the creative side of your brain—sketch out the problem, listen to some music, or just take a walk outside. Sometimes the best thing you can do to solve a problem is to put the mouse down and step away from the keyboard."
  },
  {
    "paragraph": "So, the next time you feel the need to improve your programming skills, don’t read another book. Read code."
  },
  {
    "paragraph": "Reinventing the wheel is as important to a developer’s education and skill as weightlifting is to a body builder."
  },
  {
    "paragraph": "Write code as if you had to support it for the rest of your life."
  },
  {
    "paragraph": "You leave a trail of your knowledge, attitude, tenacity, professionalism, level of commitment, and degree of enjoyment with every method, class, and module you design and write."
  },
  {
    "paragraph": "Good programming is not born from mere technical competence. I’ve seen highly intellectual programmers who can produce intense and impressive algorithms, who know their language standard by heart, but who write the most awful code. It’s painful to read, painful to use, and painful to modify. I’ve seen more humble programmers who stick to very simple code, but who write elegant and expressive programs that are a joy to work with."
  },
  {
    "paragraph": "In any coding situation, you refuse to hack something that only seems to work. You strive to craft elegant code that is clearly correct (and has good tests to show that it is correct)."
  },
  {
    "paragraph": "Any time you touch a piece of code, you strive to leave it better than you found it (either better structured, better tested, more understandable...)."
  },
  {
    "paragraph": "You care about code and about programming, so you are constantly learning new languages, idioms, and techniques. But you apply them only when appropriate."
  },
  {
    "paragraph": "Başkalarına yardım edersen, onlar da sana yardım eder."
  },
  {
    "paragraph": "Gerçek insan ilişkileri kurmak demek, başka insanların daha başarılı olmaları için imkan ve yollar sağlamak demekti."
  },
  {
    "paragraph": "Tanıdığım en başarılı insanlar, ne özel yetenekleri olanlardı, ne özel eğitimleri veya tılsımları vardı. Ortak noktaları, güvenebilecekleri, yetenekli ve ilham verebilen insanlardan oluşan, gereksinim duyduklarında yardıma koşacak bir çevreye sahip olmalarıydı."
  },
  {
    "paragraph": "İnsanlarla ilişki kurmak dediğim zaman kastettiğim budur. Sürekli olarak yardım etmek ve yardım istemek sürecidir. İnsanlar arasında ilişkiler kurarak, onlara zaman ayırarak, uzmanlığınızı paylaşarak mevcut olan ortadaki pastanın herkes için büyümesini sağlayabilirsiniz."
  },
  {
    "paragraph": "Almadan önce vermek daha iyidir. Asla da çetele tutmayın, hesap yapmayın. Yaptıklarınıza cömertliğimiz hükmederse, ödülleriniz de peşi sıra gelecektir."
  },
  {
    "paragraph": "Hedefleriniz mutlaka yazılı olmalı. Onları kağıda dökmenin büyük önemi olduğunu asla unutmamalısınız. Yazılı olmayan bir dilek, rüya olmaktan öteye geçemez. Yazılı olan dilek ise bir taahhüt, bir hedef kimliğine bürünür."
  },
  {
    "paragraph": "Oysa, çevreleri en geniş insanlar iyi bilirler ki başka insanlarla temas kurmaya henüz hiçbir şeye gereksiniminiz yokken başlamalısınız."
  },
  {
    "paragraph": "Çekingen insanlar, çekingenlerle, girişken insanlar girişkenlerle yakınlaşır."
  },
  {
    "paragraph": "Unutmayın, yapacağınız telefon görüşmesinden beklediğiniz sonucu elde edeceğinize inanmazsanız, muhtemelen sahiden de görüşmenin sonu hüsran olacaktır."
  },
  {
    "paragraph": "İnsanların size geri dönmemeleri sık karşılaşılan bir olaydı. Böyle durumlarda yapmanız gereken, egonuzu bir kenara kaldırmak ve aramak ya da mesaj göndermek konusunda ısrarcı davranmaktır. Sonunda temas sağladığınızda, sakın ola ki beklediğiniz kadar çabuk size geri dönmedikleri için şikayetçi olmayın. Bir sepet inciri berbat edersiniz, çabalarınıza yazık olur. Öte yandan, ısrarcılığınız için de özür dilememelisiniz."
  },
  {
    "paragraph": "Hiç tanışıklığınız olmayan birini ilk arayışımda, sıradışı bir saatte olmasına dikkat ederim. Meşgul insanların telefonlarını sabah sekizde ya da akşam altı buçukta açma ihtimalleri daha yüksektir."
  },
  {
    "paragraph": "Ne zaman bir yönetici asistanıyla çatışma durumuna girsem, kaybeden hep ben olurum."
  },
  {
    "paragraph": "Sekreterler ve asistanlar patronlarına yardım eden personel değildir. Gerçekten iyilerse, patronlarının iş yaşamlarında ve hatta özel yaşamlarında güvenilir arkadaşları, taraftarları ve ayrılmaz bir parçası olurlar."
  },
  {
    "paragraph": "Yeni ve önemli birine ulaşmaya çalışırken birden fazla iletişim yöntemini kullanmak bazen çok etkili olabilir. Bir e-posta, mektup, faks ya da kartpostal ulaşmak istediğiniz kişinin eline doğrudan ulaşabilir."
  },
  {
    "paragraph": "Başarısızlıktan daha kötü bir şey varsa da o da görünmezliktir. İnsanlarla iletişiminizi kesmeyin."
  },
  {
    "paragraph": "Yakın zamanda bir meslektaşınıza yemek ısmarladınız mı? Neden bir meslektaşınızı ve onunla birlikte şirketinizden ya da iş çevrenizden birkaç kişiyi daha bugün yemeğe davet etmiyorsunuz?"
  },
  {
    "paragraph": "Her başarılı insanın arkasında bir dizi başarısızlık vardır."
  },
  {
    "paragraph": "Tutkularımız bulaşıcıdır. Tutkularımız bazı insanları bize çeker."
  },
  {
    "paragraph": "Çevre edinmek anlamında en temel araçlarınızdan birinin insanlarla ilişkilerinizi sıcak tutmak, tanıştığınız insanları daha sonra da takip etmek olduğunu sakın unutmayın. Aslında, TAKİPÇİLİK HER ALANDA BAŞARININ ANAHTARIDIR."
  },
  {
    "paragraph": "Yeni tanıştığınız kişinin adınızı ve yarattığınız olumlu izlenimi hatırlamasını sağlamak, biriyle tanıştıktan hemen sonra başlatmanız gereken bir süreçtir."
  },
  {
    "paragraph": "İnsanlarla aranızı sıcak tutmayacaksanız, hayatınızda yer ayırmayacaksanız onlarla tanışma zahmetine neden katlanasınız ki?"
  },
  {
    "paragraph": "Konferanslar, insanların bir araya gelmesine vesile oluyorlar, benzer düşünceli insanlar bir araya gelerek misyon ve hedeflerine yardım edecek kişilerle tanışma fırsatı buluyorlar."
  },
  {
    "paragraph": "Soru-cevap oturumlarında elini havaya kaldıran ilk kişilerden biri olun. Sağlam ve akıl ürünü olan bir soruyla bütün dinleyici kitlesinin sizi fark etmesi işten bile değildir. Kendinizi tanıtın, hangi şirketten olduğunuzu, ne iş yaptığınızı söyleyip dinleyiciler üzerinde etki bırakacak sorunuzu yöneltin."
  },
  {
    "paragraph": "İki kişi arasında bir temas kurulması için belli bir samimiyet düzeyinin oluşması gerekir. İki dakikalık süre içinde karşınızdaki kişinin gözlerinin ve kalbinin derinliklerine bakabilmelisiniz. Can kulağıyla ne söylediğini dinlemeli, iş dışında sorular sorabilmeli ve zaaflarınıza dair bazı ufak tefek bilgiler verebilmelisiniz. Yanlış okumuyorsunuz, Zaaflarınızı gösterin diyorum. Çünkü bu, bulaşıcıdır."
  },
  {
    "paragraph": "Dünyadaki herkesin birbirinden ancak altı kademe uzakta olduğuna dair bir teori var. Teoriye göre, gezegendeki herkes bir başka kişiye ne fazla beş kişilik bir zincirle bağlanabilir. Yani tanıdığının tanıdığı mantığıyla gidilirse en fazla beşinci halkada ortak bir tanıdık bulunabilir. Peki ama bu nasıl oluyor? Çünkü o halkadaki bazı kişiler, pek çoğumuzdan daha fazla sayıda insanı tanıyor."
  },
  {
    "paragraph": "Tanıdık demek, sosyal bir güç demek demektir. Ne kadar çok tanıdığınız varsa, o kadar da çok gücünüz vardır."
  },
  {
    "paragraph": "Arkadaş çevrenizi genişletmenin ve ondan tam verimle yararlanmanın en etkin yolu kendi çevrenizle bir başkasının çevresi arasında temas sağlamanızdır."
  },
  {
    "paragraph": "Bir başkasının arkadaş çevresini paylaşıyorsanız sizi bu yeni dünyaya götüren kişiye yeterince paye vermeyi ihmal etmeyin."
  },
  {
    "paragraph": "(İletişime başlamak) Her iş dalı için başarılı olması kesin açılış lafları elbette vardır. “İşe nasıl başladınız?”, “Mesleğinizle ilgili olarak en çok sevdiiğiniz şey nedir?”, “İşinizin zor yanlarından bahseder misiniz biraz?” vs."
  },
  {
    "paragraph": "Başkalarının gözünde kendinize “özel” bir yer edinmek istiyorsanız, onların kendilerini “özel” hissetmelerini sağlamalısınız."
  },
  {
    "paragraph": "Greg’ten Johari Penceresi kavramını, pencereni karşındaki kişiye göre açıp kapaman gerektiğini öğrendiğimde ise her şey yerli yerine oturdu. Greg, kiminle konuştuğuna bakmaksızın kendisi gibi hareket eder, ama mesajını, karşındaki kişiye en uygun tonda ve sitilde verirdi."
  },
  {
    "paragraph": "“Bu gece burada muhteşem insanlar var. Gidip birkaçıyla tanışmayı denemezsem kendimi kötü hissederim. Müsadenizi isteyebilir miyim?”"
  },
  {
    "paragraph": "Uzun ömürlü bir temas sağlamak istiyorsanız, ayaküstü konuşmanızı, ilişkiyi sürdürmenize yönelik bir davet ile bitirmelisiniz. “Şaraptan gerçekten anlıyorsun. Seninle tekrar bir vesile ile buluşup bu konu hakkında konuşmayı çok isterim. En ilginç şişelerimizden birini de yanımızda getirelim, ne dersin?"
  },
  {
    "paragraph": "“Sen bir harikasın. Daha çok şey anlat lütfen.”"
  },
  {
    "paragraph": "Başkalarıyla gerçekten ilgilenin."
  },
  {
    "paragraph": "İyi bir dinleyici olun. Karşınızdaki kişinin kendisinden söz etmesi için cesaret verin."
  },
  {
    "paragraph": "Konuşmanın büyük kısmını karşınızdaki kişiye bırakın."
  },
  {
    "paragraph": "Gülümseyin"
  },
  {
    "paragraph": "Karşınızdaki kişinin ilgi alanlarına uygun şekilde konuşun."
  },
  {
    "paragraph": "Takdir duygularınızı içten ve dürüstçe gösterin."
  },
  {
    "paragraph": "Bütün insanlar, tanıştığınız her bir kişi yardım etmek ve yardımını almak için bir fırsattır."
  },
  {
    "paragraph": "İnsanlara bir şey yaptırmanın yolu, onların önemini kabul etmek ve kendilerini önemli hissettirmekten geçer."
  },
  {
    "paragraph": "İnsanların kim olduklarını, hayattaki amaçlarını anlamaya çalışmak, onları takdir etmenin ve gururlarını okşamanın en iyi yoludur."
  },
  {
    "paragraph": "Birinin amacını gerçekleştirmesine yardımcı olursanız o kişiyle aranızda bir bağ kurulmasını sağlamakla kalmazsınız, o bağın güçlü ve sürekli olmasını da sağlarsınız."
  },
  {
    "paragraph": "“Tanıştığım her insan bir şekilde benden üstündür. Ondan öğrenilecek bir şeyler vardır.”"
  },
  {
    "paragraph": "Sağlık ile ilgili bir konuda birine yardım ederseniz, birinin kişisel servetine olumlu bir etkide bulunursanız ya da çocuklarına karşı samimi bir ilgi gösterirseniz hayat boyu sürecek bir sadakati de yaratmış olursunuz."
  },
  {
    "paragraph": "İnsanların hayatlarındaki en önemli konulara girecekseniz, o konulara hak ettikleri ilgiyi göstermeniz gerektiğini unutmayın."
  },
  {
    "paragraph": "Tanıdığınız insanlara ne kadar çok şey verirseniz karşılığında o kadar çok şey alırsınız. Bir başka ifadeyle, arkadaş edinmek ve işlerinizin iyi şekilde yürümesin isitiyorsanız başkaları için elinizi taşın altına sokmalı ve zamanınızı, enerjinizi ve ilginizi vererek onlar için bir şeyler yapmalısınız."
  },
  {
    "paragraph": "Kendinizi başkaları için vazgeçilmez kılmalısınız."
  },
  {
    "paragraph": "Bir konuyu en iyi şekilde ögrenmek ve o konuda uzmanlaşmak istiyorsanız, o konuda ders verin."
  },
  {
    "paragraph": "İşin sırrı, sahip olmadığınız yeteneklerin üzerinde takıntılı bir şekilde durmamak ve güçlü yanlarınızın üzerine odaklanmaktır."
  },
  {
    "paragraph": "Amacınız, hedefiniz ne olursa olsun, kimse bunları tek başına başaramaz. Herkes kendisi dışında birçok kişinin yardımına ihtiyaç duyar."
  },
  {
    "paragraph": "(Ünlü insanlara bakarken) Halkın onları görmek istediği şekilde onları görmediğinizi ve sadece onlarla bir birey olarak ilgilendiğinizi göstermek için şöhretlerinden ve odaklarından uzak durup ilgi alanlarına yoğunlaşın."
  },
  {
    "paragraph": "(Sadece Örnek) Siyasette bugün kimsenin tanımadığı birine yardım ederseniz, o kişi yarının güçlü siyasetçisi olduğunda belki de size yardımcı olacaktır."
  },
  {
    "paragraph": "Bilgisine ihtiyaç duyduğunuz biri varsa, o kişiye yararlı olmanın yollarını bulun."
  },
  {
    "paragraph": "İşinizden nefret ediyorsanız hayatınızı da sevmezsiniz. İnsanların büyük kısmı işlerinden, sevmedikleri kişilerle çalışmak zorunda kaldıkları için nefret etmektedir. Başka insanlarla ilişki kurmak, sizi yeni ve heyecan verici işlere götürecek fırsatları iki-üç katına çıkarır."
  },
  {
    "paragraph": "There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies."
  },
  {
    "paragraph": "QPS: Queries per second.Usually how many web hits for API calls received per second."
  },
  {
    "paragraph": "Traffic: A generic term for queries, API calls, or other requests sent to a server."
  },
  {
    "paragraph": "Every minute spent simplifying a design pays off time and time again when the system is in operation."
  },
  {
    "paragraph": "A request sent to any replica should produce the same response."
  },
  {
    "paragraph": "The term fan out refers to the fact that one query results in many new queries, one to each backend. The queries “fan out” to the individual backends and the replies fan in as they are set up to the frontend and combined into the final result."
  },
  {
    "paragraph": "To query the entire dataset, the root receives the original query and forwards it to the parents. The parents forward the query to the leaf servers, which search their parts of the corpus."
  },
  {
    "paragraph": "The easiest way to store state is to put it on one machine, as depicted in Figure 1.4. Unfortunately, that method reaches its limit quite quickly: an individual machine can store only a limited amount of state and if the one machine dies we lose access to 100 percent of the state. The machine has only a certain amount of processing power, which means the number of simultaneous reads and writes it can process is limited. In distributed computing we store state by storing fractions or shards of the whole on individual machines."
  },
  {
    "paragraph": "CAP stands for consistency, availability, and partition resistance. The CAP Principle states that it is not possible to build a distributed system that guarantees consistency, availability, and resistance to partitioning. Any one or two can be achieved but not all three simultaneously. When using such systems you must be aware of which are guaranteed."
  },
  {
    "paragraph": "availability also guarantees that the system is able to report failure."
  },
  {
    "paragraph": "Partition tolerance means the system continues to operate despite arbitrary message loss or failure of part of the system. The simplest example of partition tolerance is when the system continues to operate even if the machines involved in providing the service lose the ability to communicate with each other due to a network link going down"
  },
  {
    "paragraph": "SQL and other relational databases use the term ACID to describe their side of the CAP triangle. ACID stands for Atomicity (transactions are “all or nothing”), Consistency (after each transaction the database is in a valid state), Isolation (concurrent transactions give the same results as if they were executed serially), and Durability (a committed transaction’s data will not be lost in the event of a crash or other problem). Databases that provide weaker consistency models often refer to themselves as NoSQL and describe themselves as BASE: Basically Available Soft-state services with Eventual consistency."
  },
  {
    "paragraph": "Two of the biggest consumers of time are disk access and network delays."
  },
  {
    "paragraph": "How did we know that it will take 3 disk seeks to read the index? It requires knowledge of the inner workings of the UNIX file system: how files are looked up in a directory to find an inode and how inodes are used to look up the data blocks. This is why understanding the internals of the operating system you use is key to being able to design and operate distributed systems. The internals of UNIX and UNIX-like operating systems are well documented, thus giving them an advantage over other systems."
  },
  {
    "paragraph": "composition is typically done: load balancer for many backend replicas, frontend with many different backends, and a server tree."
  },
  {
    "paragraph": "Your job is to design systems that operate."
  },
  {
    "paragraph": "Rather than the term “operational requirements,” some organizations use the term “non-functional requirements.” We consider this term misleading. While these features are not directly responsible for the function of the application or service, the term “non-functional” implies that these features do not have a function. A service cannot exist without the support of these features; they are essential."
  },
  {
    "paragraph": "occurs when the service is told to stop accepting new requests but complete any requests that are “in flight.” This is sometimes called lame-duck mode."
  },
  {
    "paragraph": "This mechanism is particularly important when using a load balancer with multiple backend replicas, as described in Section 1.3.1. Software upgrades are implemented by removing one replica at a time, upgrading it, and returning it to service. If each replica is simply “killed,” any in-flight requests will be lost. It is better to have a draining mode, where the replica continues to process requests but intentionally fails the load balancer’s health check requests. If it sees the health check requests fail, the load balancer stops sending new requests to the replica. Once no new requests have been received for a while and the existing requests are completed, it is safe to kill the replica and perform the upgrade."
  },
  {
    "paragraph": "One way to achieve live backups without interfering with the service is to perform the backup on a read-only replica of the database. If the system can dynamically add and remove replicas, a replica is removed from service, frozen, and used to make the backup. This replica is then added back to the system later. It is common to have a particular replica dedicated to this process."
  },
  {
    "paragraph": "It is good practice to segregate these kinds of queries even if the database does not have any replicas and both connections go to the same server. Someday you will want to add read-only replicas. Deciding which connection a query should use is best done when the query is originally being invented, not months or years later."
  },
  {
    "paragraph": "A configuration setting (a toggle) should be present to enable or disable each new feature. This allows roll-outs of new software releases to be independent of when the new feature is made available to users. For example, if a new feature is to appear on the site precisely at noon on Wednesday, it is very difficult to coordinate a new binary “push” exactly at that time. However, if each new feature can be individually enabled, the software can be deployed early and the feature can be enabled via changing a configuration setting at the desired time. This is often called a flag flip."
  },
  {
    "paragraph": "Google Docs deploys many graceful degradation techniques. Google’s word processor can switch into read-only mode when only a read-only database replica is available. The client-side JavaScript can work with the cached data in the browser if the server is inaccessible."
  },
  {
    "paragraph": "IP addresses are the weakest form of identification because they can be easily forged. Something better should be used, such as a public key infrastructure (PKI) that uses digital certificates to prove identity."
  },
  {
    "paragraph": "When software generates an exception, it should be collected centrally for analysis."
  },
  {
    "paragraph": "When designing software for operability, it is common to use a software framework that detects exceptions, gathers the error message and other information, and submits it to a centralized database. Such a framework is referred to as an exception collector."
  },
  {
    "paragraph": "If the vendor is unresponsive to your requests, you may be able to write code that builds frameworks around the vendor’s software. For example, you might create a wrapper that provides startup and shutdown services in a clean manner around vendor software that handles those tasks ungracefully. We highly recommend publishing such systems externally as open source products. If you need them, someone else will, too. Developing a community around your code will make its support less dependent on your own efforts."
  },
  {
    "paragraph": "A service runs on a computing infrastructure called a platform."
  },
  {
    "paragraph": "IaaS providers have expanded beyond offering just simple machines and networks. Some provide a variety of storage options, including relational (SQL) and non-relational (NoSQL or key/value) databases, high-speed storage options, and cold storage (bulk data storage that is inexpensive but has latency on the order of hours or days). More advanced networking options include virtual private network (VPN)–accessible private networks and load balancing services."
  },
  {
    "paragraph": "PaaS enables you to run your applications from a vendor-provided framework. These services offer you a high level of value, as they manage all aspects of the infrastructure, even much of the application stack. They offer very elastic scaling services, handling additional load without any input required from you. Generally you are not even aware of the specific resources dedicated to your application."
  },
  {
    "paragraph": "The downside of PaaS is that you are restricted to using what the vendor’s platform provides. The platform is generally programmable but not necessarily extensible. You do not have direct access to the operating system."
  },
  {
    "paragraph": "Virtual machines are created when a physical machine is partitioned to run a separate operating system for each partition. Processes running on a virtual machine have little or no awareness that they are not on a physical machine. They cannot access the resources, such as disk or memory, of other virtual machines running on the same physical machine."
  },
  {
    "paragraph": "Because virtual machines run a complete operating system, the operational burden is similar to a full machine that needs to be monitored, patched, upgraded, and so on. Also, because a complete operating system is running, each OS is running many background service processes such as maintenance tasks and service daemons. Those take up resources and add to the operational burden on the system administration team."
  },
  {
    "paragraph": "Containers do share some of the downsides of virtual machines. Downtime of the host machine affects all containers. This means that planned downtime for patching the host as well as unplanned outages affect all containers."
  },
  {
    "paragraph": "Containers are usually the underlying technology in PaaS. They enable customers to be isolated from each other while still sharing physical machines."
  },
  {
    "paragraph": "Systems like Docker define a standardized container for software. Rather than distributing software as a package, one can distribute a container that includes the software and everything needed for it to run. This container can be created once and run on many systems."
  },
  {
    "paragraph": "L7 load balancers work similarly to L3/L4 load balancers but make decisions based on what can be seen by peering into the application layer (Layer 7) of the protocol stack. They can examine what is inside the HTTP protocol itself (cookies, headers, URLs, and so on) and make decisions based on what was found. As a result they offer a richer mix of features than the previous load balancers. For example, the L7 load balancer can check whether a cookie has been set and send traffic to a different set of servers based on that criterion. This is how some companies handle logged-in users differently. Some companies set a special cookie when their most important customers log in and configure the load balancer to detect that cookie and send their traffic to especially fast servers."
  },
  {
    "paragraph": "When all requests appear to come from the same IP address, debugging and log analysis may be impossible at worst and confusing at best. The usual way to deal with this issue is for the load balancer to inject an additional header that indicates the IP address of the original requester. Backends can access this information as needed. This header is called X-Forwarded-For:. It contains a list of IP addresses starting with the client’s and includes all the previous proxies or load balancers that the request has passed through. Note that the client and intermediate devices can add invalid or forged addresses to the list. Therefore you can only trust the address added by your own load balancer. Using the rest is insecure and risky."
  },
  {
    "paragraph": "Least Loaded (LL):The load balancer receives information from each backend indicating how loaded it is. Incoming requests always go to the least loaded backend."
  },
  {
    "paragraph": "Least Loaded with Slow Start: This scheme is similar to LL, but when a new backend comes online it is not immediately flooded with queries. Instead, it starts receiving a low rate of traffic that slowly builds until it is receiving an appropriate amount of traffic. This fixes the problems with LL as described in Section 1.3.1."
  },
  {
    "paragraph": "Sticky Connections: Load balancers have a feature called stickiness, which means if a user ’s previous HTTP request went to a particular backend, the next one should go there as well. That solves the problem discussed earlier, at least initially. However, if that backend dies, the load balancer will send requests from that user to another backend; it has no choice. This new backend will not know the user is logged in. The user will be asked to log in again. Thus, this is only a partial solution."
  },
  {
    "paragraph": "The backends need to know that many HTTP requests are from the same user. They cannot use the source IP address of the HTTP request: due to the use of network address translation (NAT), many different machines are often seen as using the same IP address. Even if that weren’t the case, the IP address of a particular machine changes from time to time: when a laptop moves from one WiFi network to another, when a mobile device moves from WiFi to cellular and back, or if any machine is turned off and turned on again on a different (or sometimes even the same) network. Using the IP address as an identity wouldn’t even work for one user running two web browsers on the same machine. Instead, when a user logs into a web application, the web application generates a secret and includes it with the reply. The secret is something generated randomly and given to only that user on that web browser. In the future, whenever that web browser sends an HTTP request to that same web app, it also sends the secret. Because this secret was not sent to any other user, and because the secret is difficult to guess, the web app can trust that this is the same user. This scheme is known as a cookie and the secret is often referred to as a session ID."
  },
  {
    "paragraph": "• www.company.com/ (the main page)"
  },
  {
    "paragraph": "• www.company.com/sports"
  },
  {
    "paragraph": "• www.company.com/weather"
  },
  {
    "paragraph": "• www.company.com/finance"
  },
  {
    "paragraph": "• www.company.com/email"
  },
  {
    "paragraph": "Each of those web features is provided by a very different web service, but all of them can be combined into a seamlessly unified user experience by a reverse proxy. Requests go to the reverse proxy, which interprets the URL and collects the required pages from the appropriate server or service. This result is then relayed to the original requester."
  },
  {
    "paragraph": "A global load balancer (GLB) is a DNS server that directs traffic to the nearest datacenter. Normally a DNS server returns the same answer to a query no matter where the query originated. A GLB examines the source IP address of the query and returns a different result depending on the geolocation of the source IP address."
  },
  {
    "paragraph": "A point of presence (POP) is a small, remote facility used for connection to local ISPs. It is advantageous to connect to many ISPs but they cannot always connect to your datacenter. For example, your datacenter may not be in the state or country they operate in. Since they cannot go to you, you must extend your network to someplace near them. For example, you might create a POP in Berlin to connect to many different German ISPs."
  },
  {
    "paragraph": "A message bus is a mechanism whereby servers send messages to “channels” (like a radio channel) and other servers listen to the channels they need. A server that sends messages is a publisher and the receivers are subscribers."
  },
  {
    "paragraph": "A reverse proxy ensures that many application servers appear to be a single large application."
  },
  {
    "paragraph": "The only real problem is scaling. Everything else is a sub-problem."
  },
  {
    "paragraph": "The best time to fix a bottleneck is before it becomes a problem"
  },
  {
    "paragraph": "The best strategy for scaling a running system, then, is to predict problems far enough in advance that there is enough time to engineer a proper solution. This means one should always be collecting enough measurements to be aware of where the bottlenecks are."
  },
  {
    "paragraph": "Methodologies for scaling to massive proportions boil down to three basic options: replicate the entire system (horizontal duplication); split the system into individual functions, services, or resources (functional or service splits); and split the system into individual chunks (lookup or formulaic splits)."
  },
  {
    "paragraph": "One can also mark special customers for special treatment. One financial services web site sets a cookie if a user invests multiple millions of dollars with the firm. The web load balancer detects the cookie and sends its traffic to a pool of servers that are dedicated to very important customers."
  },
  {
    "paragraph": "Search engines such as Google and Bing crawl every page at Serverfault.com looking for new content. Since this crawling hits every page, it might potentially overload the service, due to both the volume of requests and the fact that hitting every page in order exhausts the cache. Both factors make performance suffer for other users. Therefore requests from web crawlers are sent to a dedicated pool of replicas. These replicas are configured not to cache the HTML pages that are generated. Because the pool is separate, if the crawlers overload it, regular users will not be affected."
  },
  {
    "paragraph": "when we do a lookup, first we check whether the result can be found in the cache. If it is, the result is used. This is called a cache hit. If it is not found, the normal lookup is done from the disk. This is called a cache miss."
  },
  {
    "paragraph": "The effectiveness of a cache is measured by the cache hit ratio, sometimes called a cache hit rate."
  },
  {
    "paragraph": "When a system starts, the cache is usually empty, or cold. The cache hit ratio will be very low and performance will remain slow until enough queries have warmed"
  },
  {
    "paragraph": "Sharding is a way to segment a database (z-axis) that is flexible, scalable, and resilient. It divides the database based on the hash value of the database keys."
  },
  {
    "paragraph": "shards are often used to distribute a read-only corpus of information."
  },
  {
    "paragraph": "The process of unadvertising until no new requests are received is called draining."
  },
  {
    "paragraph": "In a single-thread process, we receive a query, process it, send the result, and get the next query. This is simple and direct. A disadvantage is that a single long request will stall the requests behind it. It is like wanting to buy a pack of gum but being in line behind a person with a full shopping cart. In this so-called head of line blocking, the head of the line is blocked by a big request. The result is high latency for requests that otherwise could be serviced quickly."
  },
  {
    "paragraph": "A content delivery network (CDN) is a web-acceleration service that delivers content (web pages, images, video) more efficiently on behalf of your service. CDNs cache content on servers all over the world. Requests for content are serviced from the cache nearest the user. Geolocation techniques are used to identify the network location of the requesting web browser."
  },
  {
    "paragraph": "The x-axis (horizontal scaling) is a power multiplier, cloning systems or increasing their capacities to achieve greater performance. The y-axis (vertical scaling) scales by isolating transactions by their type or scope, such as using read-only database replicas for read queries and sequestering writes to the master database only. Finally, the z-axis (lookup-based scaling) is about splitting data across servers so that the workload is distributed according to data usage or physical geography."
  },
  {
    "paragraph": "Success is not final, failure is not fatal: it is the courage to continue that counts."
  },
  {
    "paragraph": "A failure domain is the bounded area beyond which failure has no impact."
  },
  {
    "paragraph": "Another technique for dealing with software hangs is called a watchdog timer. A hardware clock keeps incrementing a counter. If the counter exceeds a certain value, a hardware subsystem will detect this and reboot the system. Software running on the system resets the counter to zero after any successful operation. If the software hangs, the resets will stop and soon the system will be rebooted. As long as the software keeps running, the counter will be reset frequently enough to prevent a reboot."
  },
  {
    "paragraph": "Dean and Barroso (2013) describe a preventive measure pioneered at Google called canary requests. In situations where one would normally send the same request to thousands of leaf servers, systems using this approach send the query to one or two leaf servers. These are the canary requests. Queries are sent to the remaining servers only if replies to the canary requests are received in a reasonable period of time. If the leaf servers crash or hang while the canary requests are being processed, the system flags the request as potentially dangerous and prevents further crashes by not sending it to the remaining leaf servers. Using this technique Google is able to achieve a measure of robustness in the face of difficult-to-predict programming errors as well as malicious denial-of-service attacks."
  },
  {
    "paragraph": "One strategy is a simple failover. One load balancer (the primary) receives all traffic, and the other load balancer (the secondary) monitors the health of the primary by sending heartbeat messages to it. If a loss of heartbeat is detected, the secondary takes over and becomes the active load balancer. Any TCP connections that were “in flight” are disconnected since the primary is unaware of them."
  },
  {
    "paragraph": "Another strategy is load shedding. With this strategy the service turns away some users so that other users can have a good experience."
  },
  {
    "paragraph": "To make an analogy, an overloaded phone system doesn’t suddenly disconnect all existing calls. Instead, it responds to any new attempts to make a call with a “fast busy” tone so that the person will try to make the call later. An overloaded web site should likewise give some users an immediate response, such as a simple “come back later” web page, rather than requiring them to time out after minutes of waiting."
  },
  {
    "paragraph": "Oncall is not just a way to react to problems, but rather a way to reduce future problems."
  },
  {
    "paragraph": "In a DevOps organization, software developers and operational engineers work together as one team that shares responsibility for a web site or service"
  },
  {
    "paragraph": "DevOps is a combination of culture and practices—system administrators, software developers, and web operations staff all contribute to the DevOps environment. With DevOps, sysadmins and developers share responsibility for a service and its availability. DevOps aligns the priorities of developers (dev) and system administrators or operations staff (ops) by making them both responsible for uptime."
  },
  {
    "paragraph": "They worked in “silos,” with each group unaware of the concerns of the other, and neither side seeing the “big picture.”"
  },
  {
    "paragraph": "Stakeholders: People and organizations that are seen as having an interest in a project’s success."
  },
  {
    "paragraph": "ReleaseCandidate: The end result of the build phase. Not all release candidates are deployed."
  },
  {
    "paragraph": "The more we treat infrastructure as code, the more we can benefit from software development techniques such as revision control and testing."
  },
  {
    "paragraph": "Individual developers should each have at least one private environment for their own development needs."
  },
  {
    "paragraph": "The more confident we are in our service delivery process, the more aggressively we can try new things"
  },
  {
    "paragraph": "A software package is a container. This single file contains everything needed to install an application, patch, or library. Packages typically include the binary executables to be installed, any related data files, configuration data, and machine-interpretable instructions describing how to install and remove the software. You may be familiar with file formats such as Zip, UNIX tar, and cpio. Such files contain the contents of many smaller files plus metadata. The metadata as a whole is like a table of contents or index. It encodes information needed to unpack the individual files plus file ownership, permissions, and timestamps."
  },
  {
    "paragraph": "Continuous integration (CI) is the practice of doing the build phase many times a day in an automated fashion.uous integration (CI) is the practice of doing the build phase many times a day in an automated fashion."
  },
  {
    "paragraph": "User Acceptance Testing (UAT): This testing is done by customers to verify that the system meets their needs and to verify claims by the producer."
  },
  {
    "paragraph": "By decoupling where storage is provided from where it is used, machines become more disposable."
  },
  {
    "paragraph": "Continuous delivery (CD) is the technique in which testing is fully automated and triggered to run for each build."
  },
  {
    "paragraph": "There are two environments on the same machine, one called “blue” and the other called “green.” Green is the live environment and blue is the environment that is dormant. Both exist on the same machine by a mechanism as simple as two different subdirectories, each of which is used as a different virtual host of the same web server. The blue environment consumes very little resources. When the new release is to go live, traffic is directed to the blue environment. When the process is finished, the names of the environments are swapped. This system permits rolling back to the previous environment to take place easily. This is a very simple way of providing zero-downtime deployments on applications that weren’t designed for it, as long as the applications support being installed in two different places on the same machine."
  },
  {
    "paragraph": "The longer one waits to merge code changes into the main line source, the more difficult and risky the merge becomes. Sometimes the source code may have been changed by other developers, which creates a merge conflict. Merging small amounts of code is less error prone."
  },
  {
    "paragraph": "A-BTesting:Oftenthebestwaytotellifuserspreferonedesignoranotheristo implement both, show certain users the new feature, and observe their behavior. For example, suppose sign-ups for a product are very low. Would sign-ups be improved if a check box defaulted to checked, or if instead of a check box an entirely different mechanism was used? A group of users could be selected, half with their check box default checked (group A) and the other half with the new mechanism (group B). Whichever design has the better results would be used for all users after the test. Flag flips can be used both to control the test and to enable the winning design when the test is finished."
  },
  {
    "paragraph": "Erlang is one such language. A service written in Erlang can be upgraded while it is running. Properly structured Erlang programs are designed as eventdriven finite-state machines (FSM). For each event received, a specific function is called. One event that the service can receive is a notification that code has been upgraded. The function that is called is responsible for upgrading or converting any data structures. All subsequent events will trigger the new versions of the functions."
  },
  {
    "paragraph": "One method is to roll back to the last known good release. When problems are found, the software is uninstalled and the most recent good release is reinstalled."
  },
  {
    "paragraph": "Another method is to roll forward to the next release, which presumably fixes the problem discovered in the failed release."
  },
  {
    "paragraph": "Upgrading the software running in an environment is called a code push."
  },
  {
    "paragraph": "Progressive improvement beats delayed perfection."
  },
  {
    "paragraph": "Automation is when computers do work for us."
  },
  {
    "paragraph": "Domain-Specific Language (DSL): A language that was purpose-built for a particular use, such as system administration, mathematics, or text manipulation."
  },
  {
    "paragraph": "The co-creator of UNIX and the C programming language, Ken Thompson, famously wrote, “One of my most productive days was throwing away 1,000 lines of code."
  },
  {
    "paragraph": "Using the left-over principle, we automate everything that can be automated within reason."
  },
  {
    "paragraph": "When designing automation, ask yourself which view of the human component is being assumed by this automation."
  },
  {
    "paragraph": "Super automated systems often require super training, which can be super expensive. Hiring becomes super difficult, which begins to limit the company’s ability to grow at its desired rate. The missed opportunities that result become a burdensome cost. This opportunity cost may be more expensive than what the system saves. Such dilemmas are why companies like Google implement super aggressive recruiting campaigns to hire SREs."
  },
  {
    "paragraph": "There is a distinction between tool building and automation. Tool building improves a manual task so that it can be done better. Automation seeks to eliminate the need for the person to do the task."
  },
  {
    "paragraph": "Sometimes there isn’t enough time to automate because we’re so busy with urgent work that blocks long-term work such as creating automation. To use an analogy, we don’t have time to shut off the leaking faucet because we’re spending all of our time mopping the floor."
  },
  {
    "paragraph": "Apply any and all effort to fix the biggest bottleneck first. There may be multiple areas where automation is needed. Choose the one with the biggest impact first."
  },
  {
    "paragraph": "You can’t automate what you can’t do manually."
  },
  {
    "paragraph": "Failure is not falling down but refusing to get back up."
  },
  {
    "paragraph": "Diurnal Cycles: Metrics that are high during the day and low at night."
  },
  {
    "paragraph": "Measurement frequency is the rate at which new measurements are taken. Different metrics are collected at different frequencies. Many pieces of data are collected every 5 minutes, but some metrics are collected many times a second and others once a day or once a week."
  },
  {
    "paragraph": "A trend is the direction of a series of measurements on a metric. For example, one might use visualization to see that use of a service is growing or shrinking."
  },
  {
    "paragraph": "Alerting means to bring something to the attention of a person or another system. A sudden drop in QPS might result in alerting the oncall person. Alerts generally need to be acknowledged within a certain amount of time. If the deadline is exceeded, someone else is alerted. This process is called escalation."
  },
  {
    "paragraph": "Resolution describes how frequently the metric is collected. High (R+) is many times a second, minute, or hour. Low (R−) is many times a day."
  },
  {
    "paragraph": "Capacity Planning (CP) is the process of predicting resource needs in the future."
  },
  {
    "paragraph": "A diagnostic is a metric collected to aid technical processes such as debugging and performance tuning."
  },
  {
    "paragraph": "A common interview question is “If you could monitor only three aspects of a web server, what would they be?” This is an excellent test of technical knowledge and logical thinking. It requires you to use your technical knowledge to find one metric that can proxy for many possible problems."
  },
  {
    "paragraph": "For example, much can be learned by performing an HTTPS GET: We learn whether the server is up, if the service is overloaded, and if there is network congestion. TCP timings indicate time to first byte and time to full payload. The SSL transaction can be analyzed to monitor SSL certificate validity and expiration. The other two metrics can be used to differentiate between those issues. Knowing CPU utilization can help differentiate between network congestion and an overloaded system. Monitoring the amount of free disk space can indicate runaway processes, logs filling the disk, and many other problems."
  },
  {
    "paragraph": "Monitoring the monitoring system is called meta-monitoring."
  },
  {
    "paragraph": "Timestamps should be stored in UTC rather than local time zones."
  },
  {
    "paragraph": "Doing an HTTPS GET of a web site’s main page is an example of blackbox monitoring. The measurement is unaware of any load balancing infrastructure, internal server architecture, or which technologies are in use. Nevertheless, from this one measurement, we can determine many things: whether the site is up, how fast is it responding, if the SSL certificate has expired, if the system is producing a valid HTML document, and so on."
  },
  {
    "paragraph": "A gauge value is an amount that varies. It is analogous to a real-world gauge like one that indicates barometric pressure. Examples include an indicator of how much unused disk space is available, a temperature reading, and the number of active processes on a system. A gauge’s value varies, going up and down as whatever it measures increases or decreases."
  },
  {
    "paragraph": "A counter is a measurement that only increases—for example, a count of the number of API calls received by a service or the count of the number of packets transmitted on a network interface. A counter does not decrease or run backward."
  },
  {
    "paragraph": "Production code vs. test code"
  },
  {
    "paragraph": "People often think production code and test code are different. Tests are assumed to be an addition to production code and have no cost of ownership. By extension, people often believe that the more tests, the better. This isn’t the case. Code is a liability, not an asset. The more code you introduce, the more you extend the surface area for potential bugs in your software, and the higher the project’s upkeep cost. It’s always better to solve problems with as little code as possible."
  },
  {
    "paragraph": "Tests are code, too. You should view them as the part of your code base that aims at solving a particular problem: ensuring the application’s correctness. Unit tests, just like any other code, are also vulnerable to bugs and require maintenance."
  },
  {
    "paragraph": "The most difficult part of unit testing is achieving maximum value with minimum maintenance costs."
  },
  {
    "paragraph": "Code tends to deteriorate. Each time you change something in a code base, the amount of disorder in it, or entropy, increases. Without proper care, such as constant cleaning and refactoring, the system becomes increasingly complex and disorganized. Tests help overturn this tendency"
  },
  {
    "paragraph": "The goal of unit testing is to enable sustainable growth of the software project."
  },
  {
    "paragraph": "A unit test is an automated test that"
  },
  {
    "paragraph": "Verifies a small piece of code (also known as a unit),"
  },
  {
    "paragraph": "Does it quickly,"
  },
  {
    "paragraph": "And does it in an isolated manner."
  },
  {
    "paragraph": "A test double is an object that looks and behaves like its releaseintended counterpart but is actually a simplified version that reduces the complexity and facilitates testing."
  },
  {
    "paragraph": "if a class has a dependency on another class, or several classes, you need to replace all such dependencies with test doubles."
  },
  {
    "paragraph": "A mock is a special kind of test double that allows you to examine interactions between the system under test and its collaborators."
  },
  {
    "paragraph": "unit tests themselves should be run in isolation from each other. That way, you can run the tests in parallel, sequentially, and in any order, whatever fits you best, and they still won’t affect each other’s outcome."
  },
  {
    "paragraph": "Tests shouldn’t verify units of code. Rather, they should verify units of behavior: something that is meaningful for the problem domain and, ideally, something that a business person can recognize as useful."
  },
  {
    "paragraph": "A test should tell a story about the problem your code helps to solve, and this story should be cohesive and meaningful to a non-programmer."
  },
  {
    "paragraph": "When I call my dog, he comes right to me."
  },
  {
    "paragraph": "When I call my dog, he moves his front left leg first, then the front right leg, his head turns, the tail start wagging…"
  },
  {
    "paragraph": "Test-driven development"
  },
  {
    "paragraph": "Test-driven development is a software development process that relies on tests to drive the project development. The process consists of three (some authors specify four) stages, which you repeat for every test case:"
  },
  {
    "paragraph": "1 Write a failing test to indicate which functionality needs to be added and how it should behave."
  },
  {
    "paragraph": "2 Write just enough code to make the test pass. At this stage, the code doesn’t have to be elegant or clean."
  },
  {
    "paragraph": "3 Refactor the code. Under the protection of the passing test, you can safely clean up the code to make it more readable and maintainable."
  },
  {
    "paragraph": "an integration test is a test that verifies that your code works in integration with shared dependencies, out-of-process dependencies, or code developed by other teams in the organization. There’s also a separate notion of an end-to-end test. End-to-end tests are a subset of integration tests. They, too, check to see how your code works with out-of-process dependencies. The difference between an end-to-end test and an integration test is that end-to-end tests usually include more of such dependencies."
  },
  {
    "paragraph": "Given-When-Then pattern"
  },
  {
    "paragraph": "You might have heard of the Given-When-Then pattern, which is similar to AAA. This pattern also advocates for breaking the"
  },
  {
    "paragraph": "test down into three parts:"
  },
  {
    "paragraph": "Given—Corresponds to the arrange section  When—Corresponds to the act section"
  },
  {
    "paragraph": "Then—Corresponds to the assert section"
  },
  {
    "paragraph": "There’s no difference between the two patterns in terms of the test composition. The only distinction is that the Given-When-Then structure is more readable to nonprogrammers. Thus, Given-When-Then is more suitable for tests that are shared with non-technical people."
  },
  {
    "paragraph": "you may sometimes encounter a unit test with an if statement. This is also an anti-pattern. A test— whether a unit test or an integration test—should be a simple sequence of steps with no branching."
  },
  {
    "paragraph": "Test fixture"
  },
  {
    "paragraph": "The term test fixture has two common meanings:"
  },
  {
    "paragraph": "1 A test fixture is an object the test runs against. This object can be a regular dependency—an argument that is passed to the SUT. It can also be data in the database or a file on the hard disk. Such an object needs to remain in a known, fixed state before each test run, so it produces the same result. Hence the word fixture."
  },
  {
    "paragraph": "[MethodUnderTest]_[Scenario]_[ExpectedResult]"
  },
  {
    "paragraph": "Unit Test Naming: Name the test as if you were describing the scenario to a non-programmer who is familiar with the problem domain."
  },
  {
    "paragraph": "Separate words with underscores."
  },
  {
    "paragraph": "Don’t include the name of the SUT’s method in the test’s name."
  },
  {
    "paragraph": "Remember, you don’t test code, you test application behavior."
  },
  {
    "paragraph": "All unit tests should follow the AAA pattern: arrange, act, assert."
  },
  {
    "paragraph": "More than one line in the act section is a sign of a problem with the SUT’s API."
  },
  {
    "paragraph": "Let’s start with the first attribute of a good unit test: protection against regressions. As you know from chapter 1, a regression is a software bug. It’s when a feature stops working as intended after some code modification, usually after you roll out new functionality."
  },
  {
    "paragraph": "Refactoring means changing existing code without modifying its observable behavior. The intention is usually to improve the code’s nonfunctional characteristics: increase readability and reduce complexity. Some examples of refactoring are renaming a method and extracting a piece of code into a new class."
  },
  {
    "paragraph": "Black-box testing is a method of software testing that examines the functionality of a system without knowing its internal structure. Such testing is normally built around specifications and requirements: what the application is supposed to do, rather than how it does it."
  },
  {
    "paragraph": "White-box testing is the opposite of that. It’s a method of testing that verifies the application’s inner workings. The tests are derived from the source code, not requirements or specifications."
  },
  {
    "paragraph": "A test double is an overarching term that describes all kinds of non-production-ready, fake dependencies in tests."
  },
  {
    "paragraph": "Mocks help to emulate and examine interactions between the SUT and its dependencies, while stubs only help to emulate those interactions."
  },
  {
    "paragraph": "Test-driven development (TDD) is a workflow where you write a failing test before you write the source code. Before you write code in a component, you write a test to makes sure the component behaves correctly. A popular TDD approach is red, green, refactor. Red, green, refactor is where you write a failing test (red), make the test pass (green), and then refactor the code to make it more readable. Developing applications like this offers some benefits. First, you write source code only for the functionality that’s tested, which keeps the source code small. Second, it forces you to think about component design before you start writing code."
  },
  {
    "paragraph": "A snapshot test takes a picture of your running application and compares it against previously saved pictures."
  },
  {
    "paragraph": "The purpose of tests is to save time."
  },
  {
    "paragraph": "A journey of a thousand miles begins with a single step, and every great test suite begins with a single test."
  },
  {
    "paragraph": "Life is about the journey, not the destination."
  },
  {
    "paragraph": "Linting is a useful way to enforce code style on a project."
  },
  {
    "paragraph": "Globs are the patterns used to match files. Jest uses the Node glob module to match files."
  },
  {
    "paragraph": "Here, spec stands for specification, because unit tests are specifications for how your code should behave. Each test specifies a result to expect when the function you are testing is called."
  },
  {
    "paragraph": "Vue single-file components aren’t valid JavaScript. You need to compile them before you can use them in a JavaScript application."
  },
  {
    "paragraph": "Linting is the process of checking code for potential errors and formatting issues."
  },
  {
    "paragraph": "Frameworks are tools to make writing software easier."
  },
  {
    "paragraph": "In medicine, a false positive is where a test indicates that you have an illness, when you in fact don’t. Doctors are careful to avoid false positives, because they cause unnecessary grief to the families of the wrongly diagnosed."
  },
  {
    "paragraph": "The findAll method is to document.querySelectorAll as find is to document .querySelector."
  },
  {
    "paragraph": "To run Vue unit tests in Node, you need to use jsdom to simulate a DOM environment."
  },
  {
    "paragraph": "If you’ve used Redux before, a lot of the Vuex concepts will be familiar to you. The main difference between Vuex and Redux is that Vuex mutates the store state, whereas Redux creates a new store state on every update."
  },
  {
    "paragraph": "In the context of Vue applications, state is the data that is currently stored in a running application."
  },
  {
    "paragraph": "Actions are asynchronous. Vuex actions are like mutations, except they can be asynchronous."
  },
  {
    "paragraph": "Mutations mutate the state of a Vuex application (hence the name mutation) To call a mutation in an app, you must call a commit function with the name of the mutation."
  },
  {
    "paragraph": "In server-side routing, a new page is requested from the server and rendered."
  },
  {
    "paragraph": "Vue Router also links between pages without triggering a page load by using a RouterLink component."
  },
  {
    "paragraph": "You’ll use the history mode, which tells Vue Router to use the window.history.pushState method under the hood to set the URL without triggering a page load."
  },
  {
    "paragraph": "Snapshot testing is like having someone play a game of Spot the Differences between your latest output and a saved file of your output."
  },
  {
    "paragraph": "The fundamental difference between testing SSR code and client-side code is that it runs on the server rather than in a browser."
  },
  {
    "paragraph": "“Doğru söylüyorsunuz, Eğer insanlar zorsa, onlara karşılık vermek veya buna sinir olmak ya da kızmak hiçbir işe yaramaz.”"
  },
  {
    "paragraph": "Kısa bir kurşunkalem uzun bir hafızadan çok daha iyidir."
  },
  {
    "paragraph": "Başkalarının yanlışlarından öğrenmeliyiz. Hepsini kendimiz yapacak kadar çok zamanımız yok."
  },
  {
    "paragraph": "\u003e Birisi size hoşunuza gitmeyen bir şey söylerse ne yaparsınız?"
  },
  {
    "paragraph": "Kendinize önce şunu sorun: “Ben olsam ne hissederim?”"
  },
  {
    "paragraph": "“Yapmış olduğum bütün yanlışlar, tanık olduğum bütün saçmalıklar, işlediğim bütün hatalar düşünmeden davranmış olmamın sonucudur.” (Anonim)"
  },
  {
    "paragraph": "Düşünerek davranmayı nasıl öğrenebilirsiniz? Birisine kızdığınızda, muhtemelen olayları kendi bakış açınızdan gördüğünüzü bilirseniz, bu hiç de zor değildir. Olayları öteki kişinin bakış açısından görebilmek için şu empati cümlesini kullanın: “Ben olsam ne hissederdim?”"
  },
  {
    "paragraph": "Kişi ne kadar çok bilirse, o kadar affeder."
  },
  {
    "paragraph": "Hiddeti empatiye dönüştürün"
  },
  {
    "paragraph": "“Empati olgunluğun en iyi göstergelerinden biridir.”"
  },
  {
    "paragraph": "İnsanların size davranış tarzından hoşlanmıyorsanız, tercih edebileceğiniz iki yol vardır. Ya hiç düşünmeden karşılık verirsiniz ve aklınızın bir parçası onlarda kalır, ya da bir saniye durup olayları onların açısından gözden geçirirsiniz ve aklınız huzur içinde kalır."
  },
  {
    "paragraph": "Kendinize şunu sorun: “İnsanlar niçin bu kadar zor?”"
  },
  {
    "paragraph": "“Zayıflar hiçbir zaman affedemez. Affedebilmek güçlülere özgüdür.”"
  },
  {
    "paragraph": "“Bir öfke anında sabır gösterirsen, yüz gün üzüntü çekmekten kurtulursun.”"
  },
  {
    "paragraph": "“Bir hareketi görmezden gelmek çoğu zaman öcünü almaktan daha iyidir.”"
  },
  {
    "paragraph": "“Haklı olabiliriz ya da mutlu olabiliriz.”"
  },
  {
    "paragraph": "“Eğer başkalarının mutlu olmasını istiyorsanız, merhametli davranın. Eğer kendiniz mutlu olmak istiyorsanız, merhametli davranın.”"
  },
  {
    "paragraph": "“Eğer onları alt edemiyorsan, sen de onlara katıl.”"
  },
  {
    "paragraph": "“İnsanın, şoka uğramak yerine hafife almayı ögreninceye kadar belki de oldukça yaşlanması gerekiyor.”"
  },
  {
    "paragraph": "“Size utanç veren bir özelliğiniz varsa, bununla dalga geçenlere söylenecek en doğru şeyi bulabilmek için arkadaşlarınızın yardımına başvurun ve hüznü sevince dönüştürün.”"
  },
  {
    "paragraph": "“İnsanları güldürdüğümde benden hoşlandıklarının çok çabuk farkına vardım. Bu dersi hiçbir zaman unutmayacağım.”"
  },
  {
    "paragraph": "Mizah büyüktür, her şeyden önce kurtarıcıdır. Ortaya çıkar çıkmaz huzursuzluğumuz ve öfkemiz uçup gider ve yerini güneşli bir ruha bırakır."
  },
  {
    "paragraph": "İnsanların yanlış yanlarını tartışmak bunları derinleştirmekten başka bir işe yaramaz."
  },
  {
    "paragraph": "Hiç kimse akıl almak istemez, istedikleri sadece teyit edilmektedir."
  },
  {
    "paragraph": "S:Hiç arkadaşım yok?"
  },
  {
    "paragraph": "C:Kendinizi hiç arkadaşınız yokmuş gibi mi hissediyorsunuz?"
  },
  {
    "paragraph": "S:Evet, yüzden fazla kişinin çalıştığı bir büroda görevliyim ve iş dışında hiç kimse benimle bir kelime olsun konuşmuyor. Sanki ben yokmuşum gibi davranıyorlar."
  },
  {
    "paragraph": "C: İşyerinizdeki insanlar demek size fazla dikkat vermiyorlar. Öyle mi?"
  },
  {
    "paragraph": "Duygular mantıksal değildir ve mantığa yanıt vermezler."
  },
  {
    "paragraph": "Dertli insanların ihtiyacı köşeye sıkıştırılmak değil, hislerine kulak verilmesidir."
  },
  {
    "paragraph": "Mutsuz insanların ne yapmaları ya da ne hissetmeleri gerektiğine ilişkin söylevler dinlemek değil, gögüs kafeslerinin içinde şeyi dışarı çıkartmak istediğini unutmayın. Anlattıklarını çürütmeye çalışmak yerine geri yansıtarak kendilerine sıkıntı veren şeyi açığa vurmalarına yardımcı olabilirsiniz."
  },
  {
    "paragraph": "İnsanlar şikayet ettiğinde açıklama yapmayın. “Açıklama yapmaktan daha büyük bir zaman israfı olamaz.”"
  },
  {
    "paragraph": "Kabul Et, Özür Dile, Harekete Geç!"
  },
  {
    "paragraph": "Bütün büyük hatalarda ortada bi yerde, hatayı geri almanın ve belki de gidermenin mümkün olduğu birkaç saliselik minicik bir an hep vardır."
  },
  {
    "paragraph": "Bir şeyi doğru yapmak niçin yanlış yapıldığını açıklamaktan daha az zaman alır."
  },
  {
    "paragraph": "Çoğu insan problemlerin çevresinde dolaşmaya, onları çözmeye çalışmaktan daha çok zaman ve enerji harcıyor."
  },
  {
    "paragraph": "Başkalarının yaşamına ışık kattığınızda bu ışık size de yansır."
  },
  {
    "paragraph": "Suçun kimde olduğunu tartışıp durmak, olmuş olanı değiştirecek değildir."
  },
  {
    "paragraph": "Gerekce üretme, düzelt!"
  },
  {
    "paragraph": "Şikayetci oldukları için insanlara teşekkür edin"
  },
  {
    "paragraph": "Başarılı bir kuruluşun göstergesi, problemleri olup olmadığı değil, problemlerinin geçen seneninkilerin aynısı olup olmadığıdır."
  },
  {
    "paragraph": "How to Win customers and keep them for life"
  },
  {
    "paragraph": "The central idea of the cloud is this: instead of buying a computer, you buy compute."
  },
  {
    "paragraph": "The terms orchestration and scheduling are often used loosely as synonyms. Strictly speaking, though, orchestration in this context means coordinating and sequencing different activities in service of a common goal (like the musicians in an orchestra). Scheduling means managing the resources available and assigning workloads where they can most efficiently be run. (Not to be confused with scheduling in the sense of scheduled jobs, which execute at preset times.)"
  },
  {
    "paragraph": "Secondly, some things don’t actually need Kubernetes, and can run on what are some‐ times called serverless platforms, better named functions as a service, or FaaS plat‐ forms."
  },
  {
    "paragraph": "AWS Lambda, for example, is a FaaS platform that allows you to run code written in Go, Python, Java, Node.js, C#, and other languages, without you having to compile or deploy your application at all. Amazon does all that for you."
  },
  {
    "paragraph": "Why don’t we like to refer to this model as serverless? Well, it isn’t: it’s just somebody else’s server. The point is that you don’t have to provision and maintain that server; the cloud provider takes care of it for you."
  },
  {
    "paragraph": "A more sophisticated software delivery platform for Kubernetes that encompasses both containers and cloud functions, called Knative, is currently under active devel‐ opment"
  },
  {
    "paragraph": "Cloud native is a useful shorthand for talking about cloud-based, containerized, distributed systems, made up of cooperating microservices, dynamically managed by automated infrastructure as code."
  },
  {
    "paragraph": "Minimal containers also have a reduced attack surface for security issues. The fewer programs there are in your container, the fewer potential vulnerabilities."
  },
  {
    "paragraph": "docker image build -t myhello ."
  },
  {
    "paragraph": "Programs running in a container are isolated from other programs running on the same machine, which means they can’t have direct access to resources like network ports."
  },
  {
    "paragraph": "docker container run -p HOST_PORT:CONTAINER_PORT …"
  },
  {
    "paragraph": "docker login"
  },
  {
    "paragraph": "docker image tag myhello YOUR_DOCKER_ID/myhello"
  },
  {
    "paragraph": "docker image push YOUR_DOCKER_ID/myhello"
  },
  {
    "paragraph": "docker container run -p 9999:8888 YOUR_DOCKER_ID/myhello"
  },
  {
    "paragraph": "kubectl run demo --image=YOUR_DOCKER_ID/myhello --port=9999 --labels app=demo"
  },
  {
    "paragraph": "kubectl port-forward deploy/demo 9999:8888"
  },
  {
    "paragraph": "kubectl get pods --selector app=demo"
  },
  {
    "paragraph": "Managing Kubernetes: Operating Kubernetes Clusters in the Real World"
  },
  {
    "paragraph": "The members of the cluster which run the control plane components are called mas‐ ter nodes."
  },
  {
    "paragraph": "Cluster members that run user workloads are called worker nodes"
  },
  {
    "paragraph": "Fargate is like EC2, but instead of a virtual machine, you get a container."
  },
  {
    "paragraph": "serverless usually refers to cloud functions, or functions-as-a-service)"
  },
  {
    "paragraph": "Kubernetes clusters are made up of master nodes, which run the control plane, and worker nodes, which run your workloads."
  },
  {
    "paragraph": "What you really want is a kind of supervisor program, which continually checks that the container is running, and if it ever stops, 53 starts it again immediately. On traditional servers, you can use a tool like systemd, runit, or supervisord to do this; Docker has something similar, and you won’t be surprised to know that Kubernetes has a supervisor feature too: the Deployment."
  },
  {
    "paragraph": "Working together with the Deployment resource is a kind of Kubernetes object called a controller. Controllers watch the resources they’re responsible for, making sure they’re present and working. If a given Deployment isn’t running enough replicas, for whatever reason, the controller will create some new ones."
  },
  {
    "paragraph": "A Deployment’s job is to watch its associated containers and make sure that the speci‐ fied number of them is always running. If there are fewer, it will start more. If there are too many, it will terminate some. This is much more powerful and flexible than a traditional supervisor-type program."
  },
  {
    "paragraph": "kubectl get deployments"
  },
  {
    "paragraph": "kubectl describe deployments/demo"
  },
  {
    "paragraph": "A Pod is the Kubernetes object that represents a group of one or more containers"
  },
  {
    "paragraph": "Kubernetes controllers continually check the desired state specified by each resource against the actual state of the cluster, and make any necessary adjustments to keep them in sync. This process is called the reconciliation loop, because it loops forever, trying to reconcile the actual state with the desired state."
  },
  {
    "paragraph": "kubectl get pods --selector app=demo"
  },
  {
    "paragraph": "kubectl delete pods --selector app=demo"
  },
  {
    "paragraph": "kubectl get pods --selector app=demo"
  },
  {
    "paragraph": "Suppose you want to make a network connection to a Pod (such as our example application). How do you do that? You could find out the Pod’s IP address and con‐ nect directly to that address and the app’s port number. But the IP address may change when the Pod is restarted, so you’ll have to keep looking it up to make sure it’s up to date."
  },
  {
    "paragraph": "a Service resource gives you a single, unchanging IP address or DNS name that will be automatically routed to any matching Pod."
  },
  {
    "paragraph": "You can think of a Service as being like a web proxy or a load balancer, forwarding requests to a set of backend Pods"
  },
  {
    "paragraph": "i18n (internationalization), a11y (accessibility), and o11y (observability)."
  },
  {
    "paragraph": "If you zoom in a little, you can see that the Service is forwarding its port 9999 to the Pod’s port 8888: ..."
  },
  {
    "paragraph": "ports:"
  },
  {
    "paragraph": "port: 9999"
  },
  {
    "paragraph": "protocol: TCP"
  },
  {
    "paragraph": "targetPort: 8888"
  },
  {
    "paragraph": "kubectl apply -f k8s/service.yaml"
  },
  {
    "paragraph": "kubectl port-forward service/demo 9999:8888"
  },
  {
    "paragraph": "kubectl delete -f k8s/"
  },
  {
    "paragraph": "Shouldn’t you be able to just specify those values once, and then reference them wherever they occur through the Kubernetes manifests? For example, it would be great to be able to define variables called something like container.name and container.port, and then use them wherever they’re needed in the YAML files. Then, if you needed to change the name of the app or the port num‐ ber it listens on, you’d only have to change them in one place, and all the manifests would be updated automatically. Fortunately, there’s a tool for that, and in the final section of this chapter we’ll show you a little of what it can do."
  },
  {
    "paragraph": "One popular package manager for Kubernetes is called Helm, and it works just the way we’ve described in the previous section."
  },
  {
    "paragraph": "kubectl delete all --selector app=demo"
  },
  {
    "paragraph": "• A chart is a Helm package, containing all the resource definitions necessary to run an application in Kubernetes."
  },
  {
    "paragraph": "• A repository is a place where charts can be collected and shared."
  },
  {
    "paragraph": "• A release is a particular instance of a chart running in a Kubernetes cluster."
  },
  {
    "paragraph": "One Kuber‐ netes CPU unit is equivalent to one AWS vCPU, one Google Cloud Core, one Azure vCore, or one hyperthread on a bare-metal processor that supports hyperthreading. In other words, 1 CPU in Kubernetes terms means what you think it does. Because most Pods don’t need a whole CPU, requests and limits are usually expressed in millicpus (sometimes called millicores). Memory is measured in bytes, or more handily, mebibytes (MiB)."
  },
  {
    "paragraph": "A Kubernetes resource request specifies the minimum amount of that resource that the Pod needs to run. For example, a resource request of 100m (100 millicpus) and 250Mi (250 MiB of memory) means that the Pod cannot be scheduled on a node with less than those resources available"
  },
  {
    "paragraph": "Kubernetes allows resources to be overcommitted; that is, the sum of all the resource limits of containers on a node can exceed the total resources of that node."
  },
  {
    "paragraph": "Kubernetes lets you specify a liveness probe as part of the container spec: a health check that determines whether or not the container is alive (that is, working)."
  },
  {
    "paragraph": "The initialDelaySeconds field lets you tell Kubernetes how long to wait before try‐ ing the first liveness probe, avoiding this loop of death situation."
  },
  {
    "paragraph": "The periodSeconds field specifies how often the liveness probe should be checked; in this example, every three seconds."
  },
  {
    "paragraph": "livenessProbe:"
  },
  {
    "paragraph": "tcpSocket:"
  },
  {
    "paragraph": "port: 8888"
  },
  {
    "paragraph": "readinessProbe:"
  },
  {
    "paragraph": "exec: command:"
  },
  {
    "paragraph": "cat"
  },
  {
    "paragraph": "/tmp/healthy"
  },
  {
    "paragraph": "Related to the liveness probe, but with different semantics, is the readiness probe. Sometimes an application needs to signal to Kubernetes that it’s temporarily unable to handle requests; perhaps because it’s performing some lengthy initialization process, or waiting for some subprocess to complete. The readiness probe serves this function. If your application doesn’t start listening for HTTP until it’s ready to serve, your read‐ iness probe can be the same as your liveness probe:"
  },
  {
    "paragraph": "Normally, when a Pod starts, Kubernetes will start sending it traffic as soon as the container is in a running state. However, if the container has a readiness probe, Kubernetes will wait until the probe succeeds before sending it any requests, so that users won’t see errors from unready containers"
  },
  {
    "paragraph": "Make sure your readiness probes only return a 200 status code."
  },
  {
    "paragraph": "kubectl get namespaces"
  },
  {
    "paragraph": "kubectl get pods --namespace prod"
  },
  {
    "paragraph": "Service DNS names always follow this pattern:"
  },
  {
    "paragraph": "SERVICE.NAMESPACE.svc.cluster.local"
  },
  {
    "paragraph": "The default limit in Kubernetes is 110 Pods per node. Although you can increase this limit by adjusting the --max-pods setting of the kubelet, this may not be possible with some managed services, and it’s a good idea to stick to the Kubernetes defaults unless there is a strong reason to change them."
  },
  {
    "paragraph": "Kubernetes Jobs are Pods that run once to completion and are not restarted. However, the Job objects still exist in the Kubernetes database, and once there are a significant number of completed Jobs, this can affect API perfor‐ mance. A handy tool for cleaning up completed Jobs is kube-job-cleaner."
  },
  {
    "paragraph": "Spot instances, as AWS calls them, or preemptible VMs in Google’s terminology, pro‐ vide no availability guarantees, and are often limited in life span. Thus, they represent a trade-off between price and availability. A spot instance is cheap, but may be paused or resumed at any time, and may be ter‐ minated altogether. Fortunately, Kubernetes is designed to provide high-availability services despite the loss of individual cluster nodes."
  },
  {
    "paragraph": "Descheduler. You can run this tool every so often, as a Kubernetes Job, and it will do its best to rebalance the cluster by finding Pods that need to be moved, and killing them."
  },
  {
    "paragraph": "Liveness probes tell Kubernetes whether the container is working properly. If a container’s liveness probe fails, it will be killed and restarted."
  },
  {
    "paragraph": "Readiness probes tell Kubernetes that the container is ready and able to serve requests. If the readiness probe fails, the container will be removed from any Services that reference it, disconnecting it from user traffic."
  },
  {
    "paragraph": "ResourceQuotas let you set overall resource limits for a given namespace."
  },
  {
    "paragraph": "GPUs are high-performance parallel pro‐ cessors that are widely used for compute-intensive problems that have nothing to do with graphics, such as machine learning or data analysis."
  },
  {
    "paragraph": "Most cloud providers support autoscaling: automatically increasing or reducing the number of instances in a group according to some metric or schedule."
  },
  {
    "paragraph": "--namespace flag to just -n"
  },
  {
    "paragraph": "—selector flag to just -l (labels"
  },
  {
    "paragraph": "kubectl get po"
  },
  {
    "paragraph": "kubectl get deploy"
  },
  {
    "paragraph": "kubectl get svc"
  },
  {
    "paragraph": "kubectl get ns"
  },
  {
    "paragraph": "kubectl get pods -n kube-system -o json | jq '.items[].metadata.name'"
  },
  {
    "paragraph": "kubectl run demo --image=cloudnatived/demo:hello --dry-run -o yaml \u003edeployment.yaml"
  },
  {
    "paragraph": "kubectl apply -f deployment.yaml"
  },
  {
    "paragraph": "Use kubectl diff to check what would change before applying any updates to your production cluster."
  },
  {
    "paragraph": "In Kubernetes, logs are considered to be whatever a container writes to the standard output and standard error streams;"
  },
  {
    "paragraph": "When looking at the logs of a container isn’t enough, you might need to attach your local terminal to the container instead."
  },
  {
    "paragraph": "kubectl attach demo-54f4458547-fcx2n"
  },
  {
    "paragraph": "if you want to connect directly to a specific Pod. Just specify the Pod name and the local and remote ports:"
  },
  {
    "paragraph": "kubectl port-forward demo-54f4458547-vm88z 9999:8888"
  },
  {
    "paragraph": "kubectl run alpine --image alpine --command -sleep 999"
  },
  {
    "paragraph": "kubectl get pods"
  },
  {
    "paragraph": "kubectl exec -it alpine-7fd44fc4bf-7gl4n /bin/sh"
  },
  {
    "paragraph": "kubectl run demo --image cloudnatived/demo:hello --expose --port 8888"
  },
  {
    "paragraph": "kubectl run nslookup --image=busybox:1.28 --rm -it --restart=Never \\ --command -nslookup demo"
  },
  {
    "paragraph": "kubectl run wget --image=busybox:1.28 --rm -it --restart=Never \\ --command -wget -qOhttp://demo:8888"
  },
  {
    "paragraph": "BusyBox also includes a lightweight bash-like shell, called ash, which is compatible with standard /bin/sh shell scripts."
  },
  {
    "paragraph": "kubectl exec -it POD /bin/sh"
  },
  {
    "paragraph": "kubectl config get-contexts"
  },
  {
    "paragraph": "kubectl cluster-info"
  },
  {
    "paragraph": "kubectl config use-context gke"
  },
  {
    "paragraph": "The --dry-run option to kubectl, combined with -o YAML to get YAML output, lets you use imperative commands to generate Kubernetes manifests. This is a big time-saver when creating manifest files for new applications, for example."
  },
  {
    "paragraph": "You can turn existing resources into YAML manifests, too, using the --export flag to kubectl get."
  },
  {
    "paragraph": "Normally, the ps ax command will list all processes running on the machine, and there are usually a lot of them"
  },
  {
    "paragraph": "A good rule of thumb with a container is that it should do one thing."
  },
  {
    "paragraph": "because the two containers are in the same Pod, that connection will always be local: the two con‐ tainers will always run on the same node."
  },
  {
    "paragraph": "If you don’t specify a tag when pulling an image, the default tag is latest. For exam‐ ple, when you run an alpine image, with no tag specified, you’ll get alpine:latest."
  },
  {
    "paragraph": "You should avoid using the latest tag when deploying containers in production, because this makes it hard to track which version of the image is running and hard to roll back."
  },
  {
    "paragraph": "Images can have many tags, but only one digest. This means that if your container manifest specifies the image digest, you can guarantee deterministic deployments. An image identifier with a digest looks like this:"
  },
  {
    "paragraph": "cloudnatived/ demo@sha256:aeae1e551a6cbd60bcfd56c3b4ffec732c45b8012b7cb758c6c4a34…"
  },
  {
    "paragraph": "securityContext:"
  },
  {
    "paragraph": "runAsUser: 1000"
  },
  {
    "paragraph": "The value for runAsUser is a UID (a numerical user identifier)."
  },
  {
    "paragraph": "The simplest Volume type is emptyDir. This is a piece of ephemeral storage that starts out empty—hence the name—and stores its data on the node (either in memory, or on the node’s disk). It persists only as long as the Pod is running on that node."
  },
  {
    "paragraph": "Be careful writing to shared Volumes. Kubernetes doesn’t enforce any locking on disk writes. If two containers try to write to the same file at once, data corruption can result. To avoid this, either implement your own write-lock mechanism, or use a Volume type that supports locking, such as nfs or glusterfs."
  },
  {
    "paragraph": "kubectl get pods -l app=demo,environment=production"
  },
  {
    "paragraph": "The difference is that labels identify resources. They’re used to select groups of related resources, like in a Service’s selector. Annotations, on the other hand, are for nonidentifying information, to be used by tools or services outside Kubernetes. For example, in “Helm Hooks” on page 243 there’s an example of using annotations to control Helm workflows."
  },
  {
    "paragraph": "It may help you to remember that required means a hard affinity (the rule must be satisfied to schedule this Pod) and preferred means a soft affinity (it would be nice if the rule were satisfied, but it’s not critical)."
  },
  {
    "paragraph": "In “Node Affinities” on page 157, you learned about a property of Pods that can steer them toward (or away from) a set of nodes. Conversely, taints allow a node to repel a set of Pods, based on certain properties of the node. For example, you could use taints to create dedicated nodes: nodes that are reserved only for specific kinds of Pods. Kubernetes also creates taints for you if certain prob‐ lems exist on the node, such as low memory, or a lack of network connectivity."
  },
  {
    "paragraph": "Suppose you want to send logs from all your applications to a centralized log server, like an Elasticsearch-Logstash-Kibana (ELK) stack, or a SaaS monitoring product such as Datadog (see “Datadog” on page 301). There are a few ways to do that. You could have each application include code to connect to the logging service, authenticate, write logs, and so on, but this results in a lot of duplicated code, which is inefficient. Alternatively, you could run an extra container in every Pod that acts as a logging agent (this is called a sidecar pattern). This means each application doesn’t have to have built-in knowledge of how to talk to the logging service, but it does means you potentially have several copies of the logging agent running on each node."
  },
  {
    "paragraph": "The term daemon traditionally refers to long-running background processes on a server that handle things like logging, so by analogy, Kubernetes DaemonSets run a daemon container on each node in the cluster."
  },
  {
    "paragraph": "There are two fields that control Job execution: completions and parallelism. The first, completions, determines the number of times the specified Pod needs to run successfully before the Job is considered complete. The default value is 1, meaning the Pod will run once. The parallelism field specifies how many Pods should run at once. Again, the default value is 1, meaning that only one Pod will run at a time."
  },
  {
    "paragraph": "In Unix environments, scheduled jobs are run by the cron daemon (whose name comes from the Greek word χρόνος, meaning “time”). Accordingly, they’re known as cron jobs, and the Kubernetes Cronjob object does exactly the same thing."
  },
  {
    "paragraph": "(Horizontal scaling refers to adjusting the number of replicas of a service, in contrast to vertical scaling, which makes individual replicas bigger or smaller.) A Horizontal Pod Autoscaler (HPA) watches a specified Deployment, constantly monitoring a given metric to see if it needs to scale the number of replicas up or down."
  },
  {
    "paragraph": "A PodPreset is a type of object called an admission controller. Admission controllers watch for Pods being created and take some action when Pods matching their selector are about to be created. For example, some admission controllers might block cre‐ ation of the Pod if it violates a policy, while others, like PodPreset, inject extra config‐ uration into the Pod."
  },
  {
    "paragraph": "Istio is an example of what’s often referred to as a service mesh, and becomes very use‐ ful when teams have multiple applications and services that communicate with each other."
  },
  {
    "paragraph": "Node affinities attract or repel Pods to or from nodes with specified attributes. For example, you can specify that a Pod can only run on a node in a specified availability zone."
  },
  {
    "paragraph": "While hard node affinities can block a Pod from running, soft node affinities are more like suggestions to the scheduler. You can combine multiple soft affinities with different weights."
  },
  {
    "paragraph": "Pod affinities express a preference for Pods to be scheduled on the same node as other Pods. For example, Pods that benefit from running on the same node can express that using a Pod affinity for each other."
  },
  {
    "paragraph": "Pod anti-affinities repel other Pods instead of attracting. For example, an antiaffinity to replicas of the same Pod can help spread your replicas evenly across the cluster."
  },
  {
    "paragraph": "Taints are a way of tagging nodes with specific information; usually, about node problems or failures. By default, Pods won’t be scheduled on tainted nodes."
  },
  {
    "paragraph": "Tolerations allow a Pod to be scheduled on nodes with a specific taint. You can use this mechanism to run certain Pods only on dedicated nodes."
  },
  {
    "paragraph": "Horizontal Pod Autoscalers watch a set of Pods, trying to optimize a given metric (such as CPU utilization). They increase or decrease the desired number of repli‐ cas to achieve the specified goal."
  },
  {
    "paragraph": "PodPresets can inject bits of common configuration into all selected Pods at cre‐ ation time. For example, you could use a PodPreset to mount a particular Volume on all matching Pods."
  },
  {
    "paragraph": "The ConfigMap is the primary object for storing configuration data in Kubernetes. You can think of it as being a named set of key-value pairs that stores configuration data."
  },
  {
    "paragraph": "(the pipe symbol | in YAML indicates that what follows is a block of raw data)."
  },
  {
    "paragraph": "if the application has a way to trigger a live reload, such as a Unix signal (for example SIGHUP) or run‐ ning a command in the container."
  },
  {
    "paragraph": "Kubernetes provides a special type of object intended to store secret data: the Secret."
  },
  {
    "paragraph": "echo \"eHl6enk=\" | base64 --decode"
  },
  {
    "paragraph": "echo xyzzy | base64"
  },
  {
    "paragraph": "Hashicorp’s Vault, Square’s Keywhiz, AWS Secrets Manager, or Azure’s Key Vault"
  },
  {
    "paragraph": "Sops is an encryption tool that works with key-value files like YAML and JSON."
  },
  {
    "paragraph": "How do you associate a user with a role? You can do that using a role binding."
  },
  {
    "paragraph": "Replication is not backup. While replication may protect you from the failure of the underlying storage volume, it won’t protect you from accidentally deleting the volume by mis-clicking in a web console, for example."
  },
  {
    "paragraph": "The kubectl get componentstatuses command (or kubectl get cs for short) gives health information for the control plane components—the scheduler, the con‐ troller manager, and etcd:"
  },
  {
    "paragraph": "Security is not a product or an end goal, but an ongoing process that requires knowl‐ edge, thought, and attention."
  },
  {
    "paragraph": "Once we have this, then each application can expose not only configuration values, but also any dependencies it has on other apps or services. An intelligent package management tool could then install and run an application, along with all its depen‐ dencies, in a single command."
  },
  {
    "paragraph": "(helm package manager)"
  },
  {
    "paragraph": "The values.yaml file There is also a file named values.yaml, which contains user-modifiable settings that the chart author has exposed:"
  },
  {
    "paragraph": "kustomize is another manifest management tool that uses plain YAML, instead of templates or an alternate language like Jsonnet. You start with a base YAML manifest, and use overlays to patch the manifest for different environments or configurations."
  },
  {
    "paragraph": "To customize a Helm chart for your own requirements, create a custom values file overriding just the settings you care about, and add it to the helm install or helm upgrade command line."
  },
  {
    "paragraph": "If you had multiple replicas, a better way would be to upgrade each replica in turn, so that there’s no interruption in service: a so-called zero-downtime deployment."
  },
  {
    "paragraph": "In Kubernetes, an application’s deployment strategy is defined in the Deployment manifest. The default is RollingUpdate, so if you don’t specify a strategy, this is what you’ll get. To change the strategy to Recreate, set it like this:"
  },
  {
    "paragraph": "During a rolling update, both old and new versions of your appli‐ cation will be in service at the same time. While this usually isn’t a problem, you may need to take steps to ensure that this is safe; if your changes involve a database migration, for example (see “Han‐ dling Migrations with Helm” on page 243), a normal rolling update won’t be possible."
  },
  {
    "paragraph": "maxSurge sets the maximum number of excess Pods. For example, if you have 10 replicas and you set maxSurge to 30%, then no more than 13 Pods will be allowed to run at any one time."
  },
  {
    "paragraph": "maxUnavailable sets the maximum number of unavailable Pods. With a nominal 10 replicas and maxUnavailable of 20%, Kubernetes will never let the number of available Pods drop below 8."
  },
  {
    "paragraph": "In a blue/green deployment, rather than killing and replacing Pods one at a time, a whole new Deployment is created, and a new separate stack of Pods running v2 is launched beside the existing v1 Deployment."
  },
  {
    "paragraph": "One alternative approach that avoids this problem is a canary deployment. Like a can‐ ary in a coal mine, a small handful of new Pods are exposed to the dangerous world of production to see what happens to them. If they survive, the rollout can continue to completion. If there is a problem, the blast radius is strictly limited."
  },
  {
    "paragraph": "Helm hooks allow you to control the order in which things happen during a deploy‐ ment. They also let you bail out of an upgrade if things go wrong."
  },
  {
    "paragraph": "as a pipeline: a series of automated actions that take code from the developer’s workstation to production, via a sequence of test and acceptance stages."
  },
  {
    "paragraph": "What Does “Up” Mean? In operations we’re used to measuring the resilience and availability of our applica‐ tions in uptime, usually measured as a percentage."
  },
  {
    "paragraph": "A more sophisticated way of gathering information about your services is to use met‐ rics. As the name suggests, a metric is a numerical measure of something."
  },
  {
    "paragraph": "With black-box checks, operators have to make guesses about the internal implemen‐ tation of the app or service, and predict what kind of failures might happen and what effect this would have on external behavior. By contrast, metrics allow application developers to export key information about the hidden aspects of the system, based on their knowledge of how it actually works (and fails): Stop reverse engineering applications and start monitoring from the inside. —Kelsey Hightower, Monitorama 2016"
  },
  {
    "paragraph": "As you know, if a container’s liveness check fails, Kubernetes will restart it automati‐ cally, in an exponential backoff loop."
  },
  {
    "paragraph": "Black-box monitoring checks observe the external behavior of a system, to detect predictable failures."
  },
  {
    "paragraph": "Given that, there are two main types of metric values: counters and gauges. Counters can only go up (or reset to zero); they’re suitable for measuring things like number of requests served and number of errors received. Gauges, on the other hand, can vary up and down; they’re useful for continuously varying quantities like memory usage, or for expressing ratios of other quantities. The answers to some questions are just yes or no: whether a particular endpoint is responding to HTTP connections, for example. In this case the appropriate metric will be a gauge with a limited range of values: 0 and 1, perhaps."
  },
  {
    "paragraph": "Saturation The extent to which the resource is overloaded, or the length of the queue of requests waiting for this resource to become available. For example, if there are 10 processes waiting to run on a CPU, it has a saturation value of 10."
  },
  {
    "paragraph": "Funnel analytics (how many people hit the landing page, how many click through to the sign-up page, how many complete the transaction, and so on)"
  },
  {
    "paragraph": "Rate of sign-ups and cancellations (churn)"
  },
  {
    "paragraph": "At the lowest level, a tool called cAdvisor monitors the resource usage and perfor‐ mance statistics for the containers running on each cluster node—for example, how much CPU, memory, and disk space each container is using. cAdvisor is part of the Kubelet."
  },
  {
    "paragraph": "If no action is needed, no alert is needed. If action needs to happen sometime, but not right now, the alert can be downgraded to an email or chat message. If the action can be taken by an automated system, then automate it: don’t wake up a valuable human being."
  },
  {
    "paragraph": "You can install Prom‐ etheus in your Kubernetes cluster with one command, using a standard Helm chart (see “Helm: A Kubernetes Package Manager” on page 64). It will then gather metrics automatically from the cluster, and also from any applications you tell it to, using a process called scraping. Prometheus scrapes metrics by making an HTTP connection to your application on a prearranged port, and downloading whatever metrics data is available. It then stores the data in its database, where it will be available for you to query, graph, or alert on."
  },
  {
    "paragraph": "Datadog is a very sophisticated and powerful monitoring and analytics platform."
  },
  {
    "paragraph": "New Relic is a very well established and widely used metrics platform focused on application performance monitoring (APM)."
  },
  {
    "paragraph": "URLs describe the specific location of a resource on a particular server."
  },
  {
    "paragraph": "A URN serves as a unique name for a particular piece of content, independent of where the resource currently resides. These location-independent URNs allow resources to move from place to place. URNs also allow resources to be accessed by multiple network access protocols while maintaining the same name."
  },
  {
    "paragraph": "HEAD: Send just the HTTP headers from the response for the named resource."
  },
  {
    "paragraph": "HTTP is an application layer protocol. HTTP doesn’t worry about the nitty-gritty details of network communication; instead, it leaves the details of networking to TCP/IP, the popular reliable Internet transport protocol."
  },
  {
    "paragraph": "HTTP-NG (a.k.a. HTTP/2.0)"
  },
  {
    "paragraph": "Most URLs have the same “scheme://server location/path” structure."
  },
  {
    "paragraph": "\u003cscheme\u003e://\u003cuser\u003e:\u003cpassword\u003e@\u003chost\u003e:\u003cport\u003e/\u003cpath\u003e;\u003cparams\u003e?\u003cquery\u003e#\u003cfrag\u003e"
  },
  {
    "paragraph": "HTTP messages flow like rivers. All messages flow downstream, regardless of whether they are request messages or response messages (see Figure 3-2). The sender of any message is upstream of the receiver. In Figure 3-2, proxy 1 is upstream of proxy 3 for the request but downstream of proxy 3 for the response.*"
  },
  {
    "paragraph": "TRACE: Trace the message through proxy servers to the server."
  },
  {
    "paragraph": "OPTION: Determine what methods can operate on a server."
  },
  {
    "paragraph": "When a client makes a request, that request may have to travel through firewalls, proxies, gateways, or other applications. Each of these has the opportunity to modify the original HTTP request."
  },
  {
    "paragraph": "Upgrade Header: Gives a new version or protocol that the sender would like to “upgrade” to using"
  },
  {
    "paragraph": "Referer: Provides the URL of the document that contains the current request URI"
  },
  {
    "paragraph": "HTML designers can help eliminate this “layout delay” by explicitly adding width and height attributes to HTML tags for embedded objects such as images. Explicitly providing the width and height of the embedded image allows the browser to make graphical layout decisions before it receives the objects from the server."
  },
  {
    "paragraph": "If the client is talking to a web server, the client sends a Connection: Keep-Alive header to tell the server it wants keep-alive. The server sends a Connection: Keep-Alive header back if it supports keep-alive and doesn’t send it if it doesn’t."
  },
  {
    "paragraph": "Connection: close header to a message to indicate that a connection should close after the transaction is complete."
  },
  {
    "paragraph": "A transaction is idempotent if it yields the same result regardless of whether it is executed once or many times. Implementors can assume the GET, HEAD, PUT, DELETE, TRACE, and OPTIONS methods share this property.*"
  },
  {
    "paragraph": "In general, applications implementing graceful closes will first close their output channels and then wait for the peer on the other side of the connection to close its output channels. When both sides are done telling each other they won’t be sending any more data (i.e., closing output channels), the connection can be closed fully, with no risk of reset."
  },
  {
    "paragraph": "A web server processes HTTP requests and serves responses. The term “web server” can refer either to web server software or to the particular device or computer dedicated to serving the web pages."
  },
  {
    "paragraph": "Single-threaded web servers process one request at a time until completion. When the transaction is complete, the next connection is processed."
  },
  {
    "paragraph": "Web servers also can map URIs to dynamic resources—that is, to programs that generate content on demand (Figure 5-11). In fact, a whole class of web servers called application servers connect web servers to sophisticated backend applications."
  },
  {
    "paragraph": "HTTP/1.1’s TRACE method lets you trace a request message through a chain of proxies, observing what proxies the message passes through and how each proxy modifies the request message. TRACE is very useful for debugging proxy flows."
  },
  {
    "paragraph": "HTTP allows you to compare document “version identifiers” called entity tags (ETags). Entity tags are arbitrary labels (quoted strings) attached to the document. They might contain a serial number or version name for the document, or a checksum or other fingerprint of the document content. When the publisher makes a document change, he can change the document’s entity tag to represent this new version. Caches can then use the If-None-Match conditional header to GET a new copy of the document if the entity tags have changed."
  },
  {
    "paragraph": "Caches use entity tags to determine whether the cached version is up-to-date with respect to the server (much like they use last-modified dates). In this way, entity tags and last-modified dates both are cache validators."
  },
  {
    "paragraph": "Web tunnels let you send non-HTTP traffic through HTTP connections, allowing other protocols to piggyback on top of HTTP."
  },
  {
    "paragraph": "SSL client authentication (authentication based on X509 certificates)"
  },
  {
    "paragraph": "HTTP relays are simple HTTP proxies that do not fully adhere to the HTTP specifications. Relays process enough HTTP to establish connections, then blindly forward bytes. Because HTTP is complicated, it’s sometimes useful to implement bare-bones proxies that just blindly forward traffic, without performing all of the header and method logic. Because blind relays are easy to implement, they sometimes are used to provide simple filtering, diagnostics, or content transformation. But they should be deployed with great caution, because of the serious potential for interoperability problems."
  },
  {
    "paragraph": "Web crawlers are robots that recursively traverse information webs, fetching first one web page, then all the web pages to which that page points, then all the web pages to which those pages point, and so on. When a robot recursively follows web links, it is called a crawler or a spider because it “crawls” along the web created by HTML hyperlinks."
  },
  {
    "paragraph": "The idea of robots.txt is simple. Any web server can provide an optional file named robots.txt in the document root of the server. This file contains information about what robots can access what parts of the server. If a robot follows this voluntary standard, it will request the robots.txt file from the web site before accessing any other resource from that site."
  },
  {
    "paragraph": "HTTP began its life as an anonymous, stateless, request/response protocol."
  },
  {
    "paragraph": "The Referer header provides the URL of the page the user is coming from. The Referer header alone does not directly identify the user, but it does tell what page the user previously visited"
  },
  {
    "paragraph": "You can classify cookies broadly into two types: session cookies and persistent cookies. A session cookie is a temporary cookie that keeps track of settings and preferences as a user navigates a site. A session cookie is deleted when the user exits the browser. Persistent cookies can live longer; they are stored on disk and survive browser exits and computer restarts. Persistent cookies often are used to retain a configuration profile or login name for a site that a user visits periodically."
  },
  {
    "paragraph": "A server generating a cookie can control which sites get to see that cookie by adding a Domain attribute to the Set-Cookie response header. For example, the following HTTP response header tells the browser to send the cookie user=“mary17” to any site in the domain .airtravelbargains.com:"
  },
  {
    "paragraph": "Set-cookie: user=\"mary17\"; domain=\"airtravelbargains.com\""
  },
  {
    "paragraph": "The cookie specification even lets you associate cookies with portions of web sites. This is done using the Path attribute, which indicates the URL path prefix where each cookie is valid."
  },
  {
    "paragraph": "symmetric-key ciphers, because they use the same key value for encoding as they do for decoding"
  },
  {
    "paragraph": "Instead of a single encoding/decoding key for every pair of hosts, public-key cryptography uses two asymmetric keys: one for encoding messages for a host, and another for decoding the host’s messages. The encoding key is publicly known to the world (thus the name public-key cryptography), but only the host knows the private decoding key (see Figure 14-8)."
  },
  {
    "paragraph": "As we will see in “Transfer Encoding and Chunked Encoding,” there is one situation where you can use persistent connections without having a Content-Length header: when you use chunked encoding. Chunked encoding sends the data in a series of chunks, each with a specified size. Even if the server does not know the size of the entire entity at the time the headers are generated (often because the entity is being generated dynamically), the server can use chunked encoding to transmit pieces of well-defined size."
  },
  {
    "paragraph": "Of course, we don’t want servers encoding content in ways that the client can’t decipher. To prevent servers from using encodings that the client doesn’t support, the client passes along a list of supported content encodings in the Accept-Encoding request header."
  },
  {
    "paragraph": "Chunked encoding breaks messages into chunks of known size. Each chunk is sent one after another, eliminating the need for the size of the full message to be known before it is sent."
  },
  {
    "paragraph": "In anycast addressing, several geographically dispersed web servers have the exact same IP address and rely on the “shortest-path” routing capabilities of backbone routers to send client requests to the server nearest to the client."
  },
  {
    "paragraph": "API gateways are designed to accept traffic from out‐ side your organization or network and distribute it internally. API gateways expose your services as managed APIs, focused on transiting north-south traffic (in and out of the service mesh)."
  },
  {
    "paragraph": "Istio is an open source implementation of a service mesh first created by Google, IBM, and Lyft."
  },
  {
    "paragraph": "Service proxy: The data-plane component that handles traffic management on behalf of applica‐ tion services."
  },
  {
    "paragraph": "Zone (Istio control plane)"
  },
  {
    "paragraph": "service mesh architectures including Istio commonly comprise two planes: a control plane and data plane"
  },
  {
    "paragraph": "Istio’s data plane intercepts every packet in the request and is responsible for health checking, routing, load balancing, authentication, authorization, and generation of observable signals."
  },
  {
    "paragraph": "Data planes are responsible for intracluster communication as well as inbound (ingress) and outbound (egress) cluster network traffic."
  },
  {
    "paragraph": "With Istio, traffic is transparently intercepted using iptables rules and redirected to the service proxy."
  },
  {
    "paragraph": "The control plane in Istio provides a single point of administration for service prox‐ ies, which need programmatic configuration to be efficiently managed and have their configuration updated in real-time as services are rescheduled across your environ‐ ment"
  },
  {
    "paragraph": "Istio uses an extended version of the Envoy proxy, a high-performance proxy devel‐ oped in C++, to mediate all inbound and outbound traffic for all services in the ser‐ vice mesh. Istio uses Envoy’s features such as dynamic service discovery, load balancing, TLS termination, HTTP/2 and gRPC Remote Procedure Call (gRPC) proxying, circuit breakers, health checks, staged rollouts with percent-based traffic split, fault injection, and rich metrics."
  },
  {
    "paragraph": "Envoy is deployed as a sidecar to the relevant service in the same Kubernetes pod."
  },
  {
    "paragraph": "The sidecar proxy model also allows you to add Istio capabilities to an existing deployment with no need to redesign or rewrite code."
  },
  {
    "paragraph": "Within Istio, though Envoy is the default service proxy sidecar, it is possible to use another service proxy for your sidecar. Although there are multiple service proxies in the ecosystem, beyond Envoy, only two have currently demonstrated integration with Istio: Linkerd and NGINX."
  },
  {
    "paragraph": "Istio’s Mixer control-plane component is responsible for enforcing access control and usage policies across the service mesh and collecting telemetry data from the sidecar proxy."
  },
  {
    "paragraph": "iptables is a user-space CLI for managing host-based firewalling and packet manipu‐ lation in Linux."
  },
  {
    "paragraph": "HTTP/2 enables request multiplexing over a single TCP connection."
  },
  {
    "paragraph": "gRPC is an RPC protocol that uses protocol buffers (protobufs) on top of HTTP/2."
  },
  {
    "paragraph": "A downstream service initiates requests and receives responses."
  },
  {
    "paragraph": "An upstream service receives requests and returns responses."
  },
  {
    "paragraph": "A listener is a named network location (e.g., port, unix domain socket, etc.) that can accept connections from downstream clients."
  },
  {
    "paragraph": "As the data-plane service proxy, Envoy intercepts all incoming and outgoing requests at runtime (as traffic flows through the service mesh). This interception is done trans‐ parently via iptables rules or a Berkeley Packet Filter (BPF) program that routes all network traffic, in and out through Envoy. Envoy inspects the request and uses the request’s hostname, SNI, or service virtual IP address to determine the request’s target (the service to which the client is intending to send a request)"
  },
  {
    "paragraph": "ServiceEntrys are how you manually add/remove service listings in Istio’s service registry."
  },
  {
    "paragraph": "In a blue/green deployment, two versions, old and new, of an application are deployed side by side, and user traffic is flipped from the old set to the new. This allows for a quick fallback to the previously working version if something goes wrong, because all that’s required is reverting user traffic back to the old set from the new (as opposed to a deployment strategy such as a rolling update, in which to roll back to the previous version we must first redeploy the previous version’s binary)."
  },
  {
    "paragraph": "A canary deployment is the practice of sending a small portion of traffic to newly deployed workloads, gradually ramping up until all traffic flows the new workloads."
  },
  {
    "paragraph": "Istio provides a lot of features to help build more resilient applications; most important being client-side load balancing, circuit breaking via outlier detec‐ tion, automatic retry, and request timeouts. Istio also provides tools to inject faults into applications, allowing you to build programmatic, reproducible tests of your sys‐ tem’s resiliency."
  },
  {
    "paragraph": "Circuit breaking is a pattern of protecting calls (e.g., network calls to a remote ser‐ vice) behind a “circuit breaker.” If the protected call returns too many errors, we “trip” the circuit breaker and return errors to the caller without executing the protected call. This can be used to mitigate several classes of failure, including cascading failures. In load balancing, to “lame-duck” an endpoint is to remove it from the “active” loadbalancing set so that no traffic is sent to it for some period of time. Lame-ducking is one method that we can use to implement the circuit-breaker pattern. Outlier detection is a means of triggering lame-ducking of endpoints that are sending bad responses"
  },
  {
    "paragraph": "Every system has transient failures: network buffers overflow, a server shutting down drops a request, a downstream system fails, and so on."
  },
  {
    "paragraph": "Timeouts are important for building systems with consistent behavior. By attaching deadlines to requests, we’re able to abandon requests taking too long and free server resources."
  },
  {
    "paragraph": "Good developers know how things work. Great developers know why things work."
  },
  {
    "paragraph": "let’s assume we want to transmit a 10 Mb file over two links: 1 Mbps and 100 Mbps. It will take 10 seconds to put the entire file on the “wire” over the 1 Mbps link and only 0.1 seconds over the 100 Mbps link."
  },
  {
    "paragraph": "We may not be able to make the packets travel faster, but we can reduce the distance by strategically positioning our servers closer to the users! Leveraging a CDN to serve your data can offer significant perfor‐ mance benefits."
  },
  {
    "paragraph": "All TCP connections begin with a three-way handshake"
  },
  {
    "paragraph": "SYN"
  },
  {
    "paragraph": "Client picks a random sequence number x and sends a SYN packet, which may also include additional TCP flags and options."
  },
  {
    "paragraph": "SYN ACK"
  },
  {
    "paragraph": "Server increments x by one, picks own random sequence number y, appends its own set of flags and options, and dispatches the response."
  },
  {
    "paragraph": "ACK"
  },
  {
    "paragraph": "Client increments both x and y by one and completes the handshake by dispatching the last ACK packet in the handshake."
  },
  {
    "paragraph": "Once the three-way handshake is complete, the application data can begin to flow be‐ tween the client and the server. The client can send a data packet immediately after the ACK packet, and the server must wait for the ACK before it can dispatch any data. This startup process applies to every TCP connection and carries an important implication for performance of all network applications using TCP: each new connection will have a full roundtrip of latency before any application data can be transferred."
  },
  {
    "paragraph": "Upgrade server kernel to latest version (Linux: 3.2+)."
  },
  {
    "paragraph": "Ensure that cwnd size is set to 10."
  },
  {
    "paragraph": "Disable slow-start after idle."
  },
  {
    "paragraph": "Ensure that window scaling is enabled."
  },
  {
    "paragraph": "Eliminate redundant data transfers."
  },
  {
    "paragraph": "Compress transferred data."
  },
  {
    "paragraph": "Position servers closer to the user to reduce roundtrip times. Reuse established TCP connections whenever possible."
  },
  {
    "paragraph": "in some cases UDP may be blocked altogether by a firewall or some other network appliance—not an uncommon scenario for many enterprise networks. To address this issue, whenever STUN fails, we can use the Tra‐ versal Using Relays around NAT (TURN) protocol (RFC 5766) as a fallback, which can run over UDP and switch to TCP if all else fails."
  },
  {
    "paragraph": "ICE is a protocol, and a set of methods, that seek to establish the most efficient tunnel between the participants (Figure 3-7): direct connection where possible, leveraging STUN negotiation where needed, and finally fallback to TURN if all else fails."
  },
  {
    "paragraph": "the primary feature of UDP is all the features it omits: no connection state, handshakes, retransmissions, reassembly, reordering, congestion control, con‐ gestion avoidance, flow control, or even optional error checking."
  },
  {
    "paragraph": "When the SSL protocol was standardized by the IETF, it was re‐ named to Transport Layer Security (TLS). Many use the TLS and SSL names interchangeably, but technically, they are different, since each describes a different version of the protocol."
  },
  {
    "paragraph": "Integrity: A mechanism to detect message tampering and forgery."
  },
  {
    "paragraph": "• Both Alice and Bob generate their own public and private keys."
  },
  {
    "paragraph": "• Both Alice and Bob hide their respective private keys."
  },
  {
    "paragraph": "• Alice shares her public key with Bob, and Bob shares his with Alice."
  },
  {
    "paragraph": "• Alice generates a new message for Bob and signs it with her private key."
  },
  {
    "paragraph": "• Bob uses Alice’s public key to verify the provided message signature."
  },
  {
    "paragraph": "If we can measure it, we can improve it"
  },
  {
    "paragraph": "All decoded images are stored as memory-backed RGBA bitmaps within the browser. In turn, each RGBA image pixel requires four bytes of memory: one byte each for red, green, and blue channels, and one byte for the alpha (transparency) channel. Hence, the total memory used is simply pixel width × pixel height × 4 bytes."
  },
  {
    "paragraph": "As an exercise, how much memory will a 800 × 600 pixel bitmap require?"
  },
  {
    "paragraph": "800 × 600 × 4 bytes = 1,920,000 bytes ≈ 1.83 MB"
  },
  {
    "paragraph": "Resource inlining is another popular optimization that helps reduce the number of outbound requests by embedding the resource within the document itself: JavaScript and CSS code can be included directly in the page via the appropriate script and style HTML blocks, and other resources, such as images and even audio or PDF files, can be inlined via the data URI scheme (data:[mediatype][;base64],data):"
  },
  {
    "paragraph": "\u003cimg src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAA AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw==\" alt=\"1x1 transparent (GIF) pixel\" /\u003e"
  },
  {
    "paragraph": "In practice, a common rule of thumb is to consider inlining for resources under 1–2 KB, as resources below this threshold often incur higher HTTP overhead than the re‐ source itself"
  },
  {
    "paragraph": "In practice, a common rule of thumb is to consider inlining for resources under 1–2 KB, as resources below this threshold often incur higher HTTP overhead than the re‐ source itself"
  },
  {
    "paragraph": "The primary goals for HTTP 2.0 are to reduce latency by enabling full request and response multiplexing, minimize protocol overhead via efficient compression of HTTP header fields, and add support for request prioritization and server push."
  },
  {
    "paragraph": "HTTP 2.0 does not modify the application semantics of HTTP in any way. All the core concepts, such as HTTP methods, status codes, URIs, and header fields, remain in place. Instead, HTTP 2.0 modifies how the data is formatted (framed) and transported be‐ tween the client and server, both of whom manage the entire process, and hides all the complexity from our applications within the new framing layer. As a result, all existing applications can be delivered without modification."
  },
  {
    "paragraph": "Stream"
  },
  {
    "paragraph": "A bidirectional flow of bytes within an established connection."
  },
  {
    "paragraph": "Message"
  },
  {
    "paragraph": "A complete sequence of frames that map to a logical message."
  },
  {
    "paragraph": "Frame"
  },
  {
    "paragraph": "The smallest unit of communication in HTTP 2.0, each containing a frame header, which at minimum identifies the stream to which the frame belongs."
  },
  {
    "paragraph": "A powerful new feature of HTTP 2.0 is the ability of the server to send multiple replies for a single client request. That is, in addition to the response for the original request, the server can push additional resources to the client (Figure 12-4), without the client having to explicitly request each one!"
  },
  {
    "paragraph": "Each HTTP transfer carries a set of headers that describe the transferred resource and its properties. In HTTP 1.x, this metadata is always sent as plain text and adds anywhere from 500–800 bytes of overhead per request, and kilobytes more if HTTP cookies are required"
  },
  {
    "paragraph": "Compress assets during transfer"
  },
  {
    "paragraph": "Eliminate unnecessary request bytes"
  },
  {
    "paragraph": "Associated cookie data is automatically sent by the browser on each request."
  },
  {
    "paragraph": "In HTTP 1.x, all HTTP headers, including cookies, are transferred uncompressed."
  },
  {
    "paragraph": "The motivation for the same-origin policy is simple: the browser stores user data, such as authentication tokens, cookies, and other private metadata, which cannot be leaked across different applications—e.g., without the same origin sandbox an arbitrary script on example.com could access and manipulate users’ data on thirdparty.com!"
  },
  {
    "paragraph": "what if the server wants to offer a resource to a script running in a different origin? That’s where “Cross-Origin Resource Sharing” (CORS) comes in! CORS provides a secure opt-in mechanism for client-side cross-origin requests:"
  },
  {
    "paragraph": "To enable cookies and HTTP authentication, the client must set an extra property (withCredentials) on the XHR object when making the request, and the server must also respond with an appropriate header (Access-Control-Allow-Credentials) to indicate that it is knowingly allowing the application to include private user data."
  },
  {
    "paragraph": "Blob: Binary large object of immutable data"
  },
  {
    "paragraph": "the client can initiate a background XHR request on a periodic interval (poll the server) to check for updates. If new data is available on the server, then it is returned in the response, and otherwise the response is empty."
  },
  {
    "paragraph": "By holding the connection open until an update is available (long-polling), data can be sent immediately to the client once it becomes available on the server."
  },
  {
    "paragraph": "A Blob object represents a file-like object of immutable, raw data. If you do not need to modify the data and do not need to slice it into smaller chunks, then it is the optimal format—e.g., you can pass the entire Blob object to an image tag"
  }
]